/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package org.cloudata.thrift.generated;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;

public class ThriftCloudataService {

  public interface Iface {

    public List<ThriftTableSchema> listTables() throws ThriftIOException, TException;

    public void put(String tableName, ThriftRow row, boolean useSystemTimestamp) throws ThriftIOException, TException;

    public void removeRow(String tableName, String rowKey) throws ThriftIOException, TException;

    public void removeRowWithTime(String tableName, String rowKey, String timestamp) throws ThriftIOException, TException;

    public void remove(String tableName, String rowKey, String columnName, String cellKey) throws ThriftIOException, TException;

    public boolean hasValue(String tableName, String columnName, String rowKey) throws ThriftIOException, TException;

    public byte[] getValue(String tableName, String rowKey, String columnName, String cellKey) throws ThriftIOException, TException;

    public ThriftRow get(String tableName, String rowKey) throws ThriftIOException, TException;

    public ThriftRow getColumnRow(String tableName, String rowKey, List<String> columnNames) throws ThriftIOException, TException;

    public void createTable(ThriftTableSchema tableSchema) throws ThriftIOException, TException;

    public boolean existsTable(String tableName) throws ThriftIOException, TException;

    public void dropTable(String tableName) throws ThriftIOException, TException;

    public void truncateTable(String tableName, boolean clearPartitionInfo) throws ThriftIOException, TException;

    public void truncateColumn(String tableName, String columnName) throws ThriftIOException, TException;

    public ThriftTableSchema descTable(String tableName) throws ThriftIOException, TException;

    public void addColumn(String tableName, String addedColumnName) throws ThriftIOException, TException;

  }

  public static class Client implements Iface {
    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public List<ThriftTableSchema> listTables() throws ThriftIOException, TException
    {
      send_listTables();
      return recv_listTables();
    }

    public void send_listTables() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("listTables", TMessageType.CALL, seqid_));
      listTables_args args = new listTables_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<ThriftTableSchema> recv_listTables() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      listTables_result result = new listTables_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.tioe != null) {
        throw result.tioe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "listTables failed: unknown result");
    }

    public void put(String tableName, ThriftRow row, boolean useSystemTimestamp) throws ThriftIOException, TException
    {
      send_put(tableName, row, useSystemTimestamp);
      recv_put();
    }

    public void send_put(String tableName, ThriftRow row, boolean useSystemTimestamp) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("put", TMessageType.CALL, seqid_));
      put_args args = new put_args();
      args.tableName = tableName;
      args.row = row;
      args.useSystemTimestamp = useSystemTimestamp;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_put() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      put_result result = new put_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.tioe != null) {
        throw result.tioe;
      }
      return;
    }

    public void removeRow(String tableName, String rowKey) throws ThriftIOException, TException
    {
      send_removeRow(tableName, rowKey);
      recv_removeRow();
    }

    public void send_removeRow(String tableName, String rowKey) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("removeRow", TMessageType.CALL, seqid_));
      removeRow_args args = new removeRow_args();
      args.tableName = tableName;
      args.rowKey = rowKey;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_removeRow() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      removeRow_result result = new removeRow_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.tioe != null) {
        throw result.tioe;
      }
      return;
    }

    public void removeRowWithTime(String tableName, String rowKey, String timestamp) throws ThriftIOException, TException
    {
      send_removeRowWithTime(tableName, rowKey, timestamp);
      recv_removeRowWithTime();
    }

    public void send_removeRowWithTime(String tableName, String rowKey, String timestamp) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("removeRowWithTime", TMessageType.CALL, seqid_));
      removeRowWithTime_args args = new removeRowWithTime_args();
      args.tableName = tableName;
      args.rowKey = rowKey;
      args.timestamp = timestamp;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_removeRowWithTime() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      removeRowWithTime_result result = new removeRowWithTime_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.tioe != null) {
        throw result.tioe;
      }
      return;
    }

    public void remove(String tableName, String rowKey, String columnName, String cellKey) throws ThriftIOException, TException
    {
      send_remove(tableName, rowKey, columnName, cellKey);
      recv_remove();
    }

    public void send_remove(String tableName, String rowKey, String columnName, String cellKey) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("remove", TMessageType.CALL, seqid_));
      remove_args args = new remove_args();
      args.tableName = tableName;
      args.rowKey = rowKey;
      args.columnName = columnName;
      args.cellKey = cellKey;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_remove() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      remove_result result = new remove_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.tioe != null) {
        throw result.tioe;
      }
      return;
    }

    public boolean hasValue(String tableName, String columnName, String rowKey) throws ThriftIOException, TException
    {
      send_hasValue(tableName, columnName, rowKey);
      return recv_hasValue();
    }

    public void send_hasValue(String tableName, String columnName, String rowKey) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("hasValue", TMessageType.CALL, seqid_));
      hasValue_args args = new hasValue_args();
      args.tableName = tableName;
      args.columnName = columnName;
      args.rowKey = rowKey;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_hasValue() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      hasValue_result result = new hasValue_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.tioe != null) {
        throw result.tioe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "hasValue failed: unknown result");
    }

    public byte[] getValue(String tableName, String rowKey, String columnName, String cellKey) throws ThriftIOException, TException
    {
      send_getValue(tableName, rowKey, columnName, cellKey);
      return recv_getValue();
    }

    public void send_getValue(String tableName, String rowKey, String columnName, String cellKey) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getValue", TMessageType.CALL, seqid_));
      getValue_args args = new getValue_args();
      args.tableName = tableName;
      args.rowKey = rowKey;
      args.columnName = columnName;
      args.cellKey = cellKey;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public byte[] recv_getValue() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getValue_result result = new getValue_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.tioe != null) {
        throw result.tioe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getValue failed: unknown result");
    }

    public ThriftRow get(String tableName, String rowKey) throws ThriftIOException, TException
    {
      send_get(tableName, rowKey);
      return recv_get();
    }

    public void send_get(String tableName, String rowKey) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get", TMessageType.CALL, seqid_));
      get_args args = new get_args();
      args.tableName = tableName;
      args.rowKey = rowKey;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public ThriftRow recv_get() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_result result = new get_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.tioe != null) {
        throw result.tioe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get failed: unknown result");
    }

    public ThriftRow getColumnRow(String tableName, String rowKey, List<String> columnNames) throws ThriftIOException, TException
    {
      send_getColumnRow(tableName, rowKey, columnNames);
      return recv_getColumnRow();
    }

    public void send_getColumnRow(String tableName, String rowKey, List<String> columnNames) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getColumnRow", TMessageType.CALL, seqid_));
      getColumnRow_args args = new getColumnRow_args();
      args.tableName = tableName;
      args.rowKey = rowKey;
      args.columnNames = columnNames;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public ThriftRow recv_getColumnRow() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getColumnRow_result result = new getColumnRow_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.tioe != null) {
        throw result.tioe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getColumnRow failed: unknown result");
    }

    public void createTable(ThriftTableSchema tableSchema) throws ThriftIOException, TException
    {
      send_createTable(tableSchema);
      recv_createTable();
    }

    public void send_createTable(ThriftTableSchema tableSchema) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("createTable", TMessageType.CALL, seqid_));
      createTable_args args = new createTable_args();
      args.tableSchema = tableSchema;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_createTable() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      createTable_result result = new createTable_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.tioe != null) {
        throw result.tioe;
      }
      return;
    }

    public boolean existsTable(String tableName) throws ThriftIOException, TException
    {
      send_existsTable(tableName);
      return recv_existsTable();
    }

    public void send_existsTable(String tableName) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("existsTable", TMessageType.CALL, seqid_));
      existsTable_args args = new existsTable_args();
      args.tableName = tableName;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_existsTable() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      existsTable_result result = new existsTable_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.tioe != null) {
        throw result.tioe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "existsTable failed: unknown result");
    }

    public void dropTable(String tableName) throws ThriftIOException, TException
    {
      send_dropTable(tableName);
      recv_dropTable();
    }

    public void send_dropTable(String tableName) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("dropTable", TMessageType.CALL, seqid_));
      dropTable_args args = new dropTable_args();
      args.tableName = tableName;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_dropTable() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dropTable_result result = new dropTable_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.tioe != null) {
        throw result.tioe;
      }
      return;
    }

    public void truncateTable(String tableName, boolean clearPartitionInfo) throws ThriftIOException, TException
    {
      send_truncateTable(tableName, clearPartitionInfo);
      recv_truncateTable();
    }

    public void send_truncateTable(String tableName, boolean clearPartitionInfo) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("truncateTable", TMessageType.CALL, seqid_));
      truncateTable_args args = new truncateTable_args();
      args.tableName = tableName;
      args.clearPartitionInfo = clearPartitionInfo;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_truncateTable() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      truncateTable_result result = new truncateTable_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.tioe != null) {
        throw result.tioe;
      }
      return;
    }

    public void truncateColumn(String tableName, String columnName) throws ThriftIOException, TException
    {
      send_truncateColumn(tableName, columnName);
      recv_truncateColumn();
    }

    public void send_truncateColumn(String tableName, String columnName) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("truncateColumn", TMessageType.CALL, seqid_));
      truncateColumn_args args = new truncateColumn_args();
      args.tableName = tableName;
      args.columnName = columnName;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_truncateColumn() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      truncateColumn_result result = new truncateColumn_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.tioe != null) {
        throw result.tioe;
      }
      return;
    }

    public ThriftTableSchema descTable(String tableName) throws ThriftIOException, TException
    {
      send_descTable(tableName);
      return recv_descTable();
    }

    public void send_descTable(String tableName) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("descTable", TMessageType.CALL, seqid_));
      descTable_args args = new descTable_args();
      args.tableName = tableName;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public ThriftTableSchema recv_descTable() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      descTable_result result = new descTable_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.tioe != null) {
        throw result.tioe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "descTable failed: unknown result");
    }

    public void addColumn(String tableName, String addedColumnName) throws ThriftIOException, TException
    {
      send_addColumn(tableName, addedColumnName);
      recv_addColumn();
    }

    public void send_addColumn(String tableName, String addedColumnName) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("addColumn", TMessageType.CALL, seqid_));
      addColumn_args args = new addColumn_args();
      args.tableName = tableName;
      args.addedColumnName = addedColumnName;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_addColumn() throws ThriftIOException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      addColumn_result result = new addColumn_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.tioe != null) {
        throw result.tioe;
      }
      return;
    }

  }
  public static class Processor implements TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("listTables", new listTables());
      processMap_.put("put", new put());
      processMap_.put("removeRow", new removeRow());
      processMap_.put("removeRowWithTime", new removeRowWithTime());
      processMap_.put("remove", new remove());
      processMap_.put("hasValue", new hasValue());
      processMap_.put("getValue", new getValue());
      processMap_.put("get", new get());
      processMap_.put("getColumnRow", new getColumnRow());
      processMap_.put("createTable", new createTable());
      processMap_.put("existsTable", new existsTable());
      processMap_.put("dropTable", new dropTable());
      processMap_.put("truncateTable", new truncateTable());
      processMap_.put("truncateColumn", new truncateColumn());
      processMap_.put("descTable", new descTable());
      processMap_.put("addColumn", new addColumn());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class listTables implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        listTables_args args = new listTables_args();
        args.read(iprot);
        iprot.readMessageEnd();
        listTables_result result = new listTables_result();
        try {
          result.success = iface_.listTables();
        } catch (ThriftIOException tioe) {
          result.tioe = tioe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing listTables", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing listTables");
          oprot.writeMessageBegin(new TMessage("listTables", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("listTables", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class put implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        put_args args = new put_args();
        args.read(iprot);
        iprot.readMessageEnd();
        put_result result = new put_result();
        try {
          iface_.put(args.tableName, args.row, args.useSystemTimestamp);
        } catch (ThriftIOException tioe) {
          result.tioe = tioe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing put", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing put");
          oprot.writeMessageBegin(new TMessage("put", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("put", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class removeRow implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        removeRow_args args = new removeRow_args();
        args.read(iprot);
        iprot.readMessageEnd();
        removeRow_result result = new removeRow_result();
        try {
          iface_.removeRow(args.tableName, args.rowKey);
        } catch (ThriftIOException tioe) {
          result.tioe = tioe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing removeRow", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing removeRow");
          oprot.writeMessageBegin(new TMessage("removeRow", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("removeRow", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class removeRowWithTime implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        removeRowWithTime_args args = new removeRowWithTime_args();
        args.read(iprot);
        iprot.readMessageEnd();
        removeRowWithTime_result result = new removeRowWithTime_result();
        try {
          iface_.removeRowWithTime(args.tableName, args.rowKey, args.timestamp);
        } catch (ThriftIOException tioe) {
          result.tioe = tioe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing removeRowWithTime", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing removeRowWithTime");
          oprot.writeMessageBegin(new TMessage("removeRowWithTime", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("removeRowWithTime", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class remove implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        remove_args args = new remove_args();
        args.read(iprot);
        iprot.readMessageEnd();
        remove_result result = new remove_result();
        try {
          iface_.remove(args.tableName, args.rowKey, args.columnName, args.cellKey);
        } catch (ThriftIOException tioe) {
          result.tioe = tioe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing remove", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing remove");
          oprot.writeMessageBegin(new TMessage("remove", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("remove", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class hasValue implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        hasValue_args args = new hasValue_args();
        args.read(iprot);
        iprot.readMessageEnd();
        hasValue_result result = new hasValue_result();
        try {
          result.success = iface_.hasValue(args.tableName, args.columnName, args.rowKey);
          result.setSuccessIsSet(true);
        } catch (ThriftIOException tioe) {
          result.tioe = tioe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing hasValue", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing hasValue");
          oprot.writeMessageBegin(new TMessage("hasValue", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("hasValue", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getValue implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getValue_args args = new getValue_args();
        args.read(iprot);
        iprot.readMessageEnd();
        getValue_result result = new getValue_result();
        try {
          result.success = iface_.getValue(args.tableName, args.rowKey, args.columnName, args.cellKey);
        } catch (ThriftIOException tioe) {
          result.tioe = tioe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getValue", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getValue");
          oprot.writeMessageBegin(new TMessage("getValue", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getValue", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_args args = new get_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_result result = new get_result();
        try {
          result.success = iface_.get(args.tableName, args.rowKey);
        } catch (ThriftIOException tioe) {
          result.tioe = tioe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get");
          oprot.writeMessageBegin(new TMessage("get", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getColumnRow implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getColumnRow_args args = new getColumnRow_args();
        args.read(iprot);
        iprot.readMessageEnd();
        getColumnRow_result result = new getColumnRow_result();
        try {
          result.success = iface_.getColumnRow(args.tableName, args.rowKey, args.columnNames);
        } catch (ThriftIOException tioe) {
          result.tioe = tioe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getColumnRow", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getColumnRow");
          oprot.writeMessageBegin(new TMessage("getColumnRow", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getColumnRow", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class createTable implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        createTable_args args = new createTable_args();
        args.read(iprot);
        iprot.readMessageEnd();
        createTable_result result = new createTable_result();
        try {
          iface_.createTable(args.tableSchema);
        } catch (ThriftIOException tioe) {
          result.tioe = tioe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing createTable", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing createTable");
          oprot.writeMessageBegin(new TMessage("createTable", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("createTable", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class existsTable implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        existsTable_args args = new existsTable_args();
        args.read(iprot);
        iprot.readMessageEnd();
        existsTable_result result = new existsTable_result();
        try {
          result.success = iface_.existsTable(args.tableName);
          result.setSuccessIsSet(true);
        } catch (ThriftIOException tioe) {
          result.tioe = tioe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing existsTable", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing existsTable");
          oprot.writeMessageBegin(new TMessage("existsTable", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("existsTable", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class dropTable implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        dropTable_args args = new dropTable_args();
        args.read(iprot);
        iprot.readMessageEnd();
        dropTable_result result = new dropTable_result();
        try {
          iface_.dropTable(args.tableName);
        } catch (ThriftIOException tioe) {
          result.tioe = tioe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing dropTable", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing dropTable");
          oprot.writeMessageBegin(new TMessage("dropTable", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("dropTable", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class truncateTable implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        truncateTable_args args = new truncateTable_args();
        args.read(iprot);
        iprot.readMessageEnd();
        truncateTable_result result = new truncateTable_result();
        try {
          iface_.truncateTable(args.tableName, args.clearPartitionInfo);
        } catch (ThriftIOException tioe) {
          result.tioe = tioe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing truncateTable", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing truncateTable");
          oprot.writeMessageBegin(new TMessage("truncateTable", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("truncateTable", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class truncateColumn implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        truncateColumn_args args = new truncateColumn_args();
        args.read(iprot);
        iprot.readMessageEnd();
        truncateColumn_result result = new truncateColumn_result();
        try {
          iface_.truncateColumn(args.tableName, args.columnName);
        } catch (ThriftIOException tioe) {
          result.tioe = tioe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing truncateColumn", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing truncateColumn");
          oprot.writeMessageBegin(new TMessage("truncateColumn", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("truncateColumn", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class descTable implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        descTable_args args = new descTable_args();
        args.read(iprot);
        iprot.readMessageEnd();
        descTable_result result = new descTable_result();
        try {
          result.success = iface_.descTable(args.tableName);
        } catch (ThriftIOException tioe) {
          result.tioe = tioe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing descTable", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing descTable");
          oprot.writeMessageBegin(new TMessage("descTable", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("descTable", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class addColumn implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        addColumn_args args = new addColumn_args();
        args.read(iprot);
        iprot.readMessageEnd();
        addColumn_result result = new addColumn_result();
        try {
          iface_.addColumn(args.tableName, args.addedColumnName);
        } catch (ThriftIOException tioe) {
          result.tioe = tioe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing addColumn", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing addColumn");
          oprot.writeMessageBegin(new TMessage("addColumn", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("addColumn", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class listTables_args implements TBase<listTables_args._Fields>, java.io.Serializable, Cloneable, Comparable<listTables_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("listTables_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(listTables_args.class, metaDataMap);
    }

    public listTables_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTables_args(listTables_args other) {
    }

    public listTables_args deepCopy() {
      return new listTables_args(this);
    }

    @Deprecated
    public listTables_args clone() {
      return new listTables_args(this);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listTables_args)
        return this.equals((listTables_args)that);
      return false;
    }

    public boolean equals(listTables_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(listTables_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      listTables_args typedOther = (listTables_args)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("listTables_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class listTables_result implements TBase<listTables_result._Fields>, java.io.Serializable, Cloneable, Comparable<listTables_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("listTables_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField TIOE_FIELD_DESC = new TField("tioe", TType.STRUCT, (short)1);

    public List<ThriftTableSchema> success;
    public ThriftIOException tioe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      TIOE((short)1, "tioe");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, ThriftTableSchema.class))));
      put(_Fields.TIOE, new FieldMetaData("tioe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(listTables_result.class, metaDataMap);
    }

    public listTables_result() {
    }

    public listTables_result(
      List<ThriftTableSchema> success,
      ThriftIOException tioe)
    {
      this();
      this.success = success;
      this.tioe = tioe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public listTables_result(listTables_result other) {
      if (other.isSetSuccess()) {
        List<ThriftTableSchema> __this__success = new ArrayList<ThriftTableSchema>();
        for (ThriftTableSchema other_element : other.success) {
          __this__success.add(new ThriftTableSchema(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetTioe()) {
        this.tioe = new ThriftIOException(other.tioe);
      }
    }

    public listTables_result deepCopy() {
      return new listTables_result(this);
    }

    @Deprecated
    public listTables_result clone() {
      return new listTables_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<ThriftTableSchema> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(ThriftTableSchema elem) {
      if (this.success == null) {
        this.success = new ArrayList<ThriftTableSchema>();
      }
      this.success.add(elem);
    }

    public List<ThriftTableSchema> getSuccess() {
      return this.success;
    }

    public listTables_result setSuccess(List<ThriftTableSchema> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThriftIOException getTioe() {
      return this.tioe;
    }

    public listTables_result setTioe(ThriftIOException tioe) {
      this.tioe = tioe;
      return this;
    }

    public void unsetTioe() {
      this.tioe = null;
    }

    /** Returns true if field tioe is set (has been asigned a value) and false otherwise */
    public boolean isSetTioe() {
      return this.tioe != null;
    }

    public void setTioeIsSet(boolean value) {
      if (!value) {
        this.tioe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<ThriftTableSchema>)value);
        }
        break;

      case TIOE:
        if (value == null) {
          unsetTioe();
        } else {
          setTioe((ThriftIOException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case TIOE:
        return getTioe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case TIOE:
        return isSetTioe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof listTables_result)
        return this.equals((listTables_result)that);
      return false;
    }

    public boolean equals(listTables_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_tioe = true && this.isSetTioe();
      boolean that_present_tioe = true && that.isSetTioe();
      if (this_present_tioe || that_present_tioe) {
        if (!(this_present_tioe && that_present_tioe))
          return false;
        if (!this.tioe.equals(that.tioe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(listTables_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      listTables_result typedOther = (listTables_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetTioe()).compareTo(isSetTioe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tioe, typedOther.tioe);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case SUCCESS:
              if (field.type == TType.LIST) {
                {
                  TList _list17 = iprot.readListBegin();
                  this.success = new ArrayList<ThriftTableSchema>(_list17.size);
                  for (int _i18 = 0; _i18 < _list17.size; ++_i18)
                  {
                    ThriftTableSchema _elem19;
                    _elem19 = new ThriftTableSchema();
                    _elem19.read(iprot);
                    this.success.add(_elem19);
                  }
                  iprot.readListEnd();
                }
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case TIOE:
              if (field.type == TType.STRUCT) {
                this.tioe = new ThriftIOException();
                this.tioe.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (ThriftTableSchema _iter20 : this.success)
          {
            _iter20.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetTioe()) {
        oprot.writeFieldBegin(TIOE_FIELD_DESC);
        this.tioe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("listTables_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tioe:");
      if (this.tioe == null) {
        sb.append("null");
      } else {
        sb.append(this.tioe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class put_args implements TBase<put_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("put_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_FIELD_DESC = new TField("row", TType.STRUCT, (short)2);
    private static final TField USE_SYSTEM_TIMESTAMP_FIELD_DESC = new TField("useSystemTimestamp", TType.BOOL, (short)3);

    public String tableName;
    public ThriftRow row;
    public boolean useSystemTimestamp;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TABLE_NAME((short)1, "tableName"),
      ROW((short)2, "row"),
      USE_SYSTEM_TIMESTAMP((short)3, "useSystemTimestamp");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __USESYSTEMTIMESTAMP_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.ROW, new FieldMetaData("row", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ThriftRow.class)));
      put(_Fields.USE_SYSTEM_TIMESTAMP, new FieldMetaData("useSystemTimestamp", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(put_args.class, metaDataMap);
    }

    public put_args() {
    }

    public put_args(
      String tableName,
      ThriftRow row,
      boolean useSystemTimestamp)
    {
      this();
      this.tableName = tableName;
      this.row = row;
      this.useSystemTimestamp = useSystemTimestamp;
      setUseSystemTimestampIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public put_args(put_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRow()) {
        this.row = new ThriftRow(other.row);
      }
      this.useSystemTimestamp = other.useSystemTimestamp;
    }

    public put_args deepCopy() {
      return new put_args(this);
    }

    @Deprecated
    public put_args clone() {
      return new put_args(this);
    }

    public String getTableName() {
      return this.tableName;
    }

    public put_args setTableName(String tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public ThriftRow getRow() {
      return this.row;
    }

    public put_args setRow(ThriftRow row) {
      this.row = row;
      return this;
    }

    public void unsetRow() {
      this.row = null;
    }

    /** Returns true if field row is set (has been asigned a value) and false otherwise */
    public boolean isSetRow() {
      return this.row != null;
    }

    public void setRowIsSet(boolean value) {
      if (!value) {
        this.row = null;
      }
    }

    public boolean isUseSystemTimestamp() {
      return this.useSystemTimestamp;
    }

    public put_args setUseSystemTimestamp(boolean useSystemTimestamp) {
      this.useSystemTimestamp = useSystemTimestamp;
      setUseSystemTimestampIsSet(true);
      return this;
    }

    public void unsetUseSystemTimestamp() {
      __isset_bit_vector.clear(__USESYSTEMTIMESTAMP_ISSET_ID);
    }

    /** Returns true if field useSystemTimestamp is set (has been asigned a value) and false otherwise */
    public boolean isSetUseSystemTimestamp() {
      return __isset_bit_vector.get(__USESYSTEMTIMESTAMP_ISSET_ID);
    }

    public void setUseSystemTimestampIsSet(boolean value) {
      __isset_bit_vector.set(__USESYSTEMTIMESTAMP_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((String)value);
        }
        break;

      case ROW:
        if (value == null) {
          unsetRow();
        } else {
          setRow((ThriftRow)value);
        }
        break;

      case USE_SYSTEM_TIMESTAMP:
        if (value == null) {
          unsetUseSystemTimestamp();
        } else {
          setUseSystemTimestamp((Boolean)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW:
        return getRow();

      case USE_SYSTEM_TIMESTAMP:
        return new Boolean(isUseSystemTimestamp());

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW:
        return isSetRow();
      case USE_SYSTEM_TIMESTAMP:
        return isSetUseSystemTimestamp();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof put_args)
        return this.equals((put_args)that);
      return false;
    }

    public boolean equals(put_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_row = true && this.isSetRow();
      boolean that_present_row = true && that.isSetRow();
      if (this_present_row || that_present_row) {
        if (!(this_present_row && that_present_row))
          return false;
        if (!this.row.equals(that.row))
          return false;
      }

      boolean this_present_useSystemTimestamp = true;
      boolean that_present_useSystemTimestamp = true;
      if (this_present_useSystemTimestamp || that_present_useSystemTimestamp) {
        if (!(this_present_useSystemTimestamp && that_present_useSystemTimestamp))
          return false;
        if (this.useSystemTimestamp != that.useSystemTimestamp)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TABLE_NAME:
              if (field.type == TType.STRING) {
                this.tableName = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case ROW:
              if (field.type == TType.STRUCT) {
                this.row = new ThriftRow();
                this.row.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case USE_SYSTEM_TIMESTAMP:
              if (field.type == TType.BOOL) {
                this.useSystemTimestamp = iprot.readBool();
                setUseSystemTimestampIsSet(true);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.row != null) {
        oprot.writeFieldBegin(ROW_FIELD_DESC);
        this.row.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(USE_SYSTEM_TIMESTAMP_FIELD_DESC);
      oprot.writeBool(this.useSystemTimestamp);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("put_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("row:");
      if (this.row == null) {
        sb.append("null");
      } else {
        sb.append(this.row);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("useSystemTimestamp:");
      sb.append(this.useSystemTimestamp);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class put_result implements TBase<put_result._Fields>, java.io.Serializable, Cloneable, Comparable<put_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("put_result");

    private static final TField TIOE_FIELD_DESC = new TField("tioe", TType.STRUCT, (short)1);

    public ThriftIOException tioe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TIOE((short)1, "tioe");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TIOE, new FieldMetaData("tioe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(put_result.class, metaDataMap);
    }

    public put_result() {
    }

    public put_result(
      ThriftIOException tioe)
    {
      this();
      this.tioe = tioe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public put_result(put_result other) {
      if (other.isSetTioe()) {
        this.tioe = new ThriftIOException(other.tioe);
      }
    }

    public put_result deepCopy() {
      return new put_result(this);
    }

    @Deprecated
    public put_result clone() {
      return new put_result(this);
    }

    public ThriftIOException getTioe() {
      return this.tioe;
    }

    public put_result setTioe(ThriftIOException tioe) {
      this.tioe = tioe;
      return this;
    }

    public void unsetTioe() {
      this.tioe = null;
    }

    /** Returns true if field tioe is set (has been asigned a value) and false otherwise */
    public boolean isSetTioe() {
      return this.tioe != null;
    }

    public void setTioeIsSet(boolean value) {
      if (!value) {
        this.tioe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TIOE:
        if (value == null) {
          unsetTioe();
        } else {
          setTioe((ThriftIOException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TIOE:
        return getTioe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TIOE:
        return isSetTioe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof put_result)
        return this.equals((put_result)that);
      return false;
    }

    public boolean equals(put_result that) {
      if (that == null)
        return false;

      boolean this_present_tioe = true && this.isSetTioe();
      boolean that_present_tioe = true && that.isSetTioe();
      if (this_present_tioe || that_present_tioe) {
        if (!(this_present_tioe && that_present_tioe))
          return false;
        if (!this.tioe.equals(that.tioe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(put_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      put_result typedOther = (put_result)other;

      lastComparison = Boolean.valueOf(isSetTioe()).compareTo(isSetTioe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tioe, typedOther.tioe);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TIOE:
              if (field.type == TType.STRUCT) {
                this.tioe = new ThriftIOException();
                this.tioe.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetTioe()) {
        oprot.writeFieldBegin(TIOE_FIELD_DESC);
        this.tioe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("put_result(");
      boolean first = true;

      sb.append("tioe:");
      if (this.tioe == null) {
        sb.append("null");
      } else {
        sb.append(this.tioe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class removeRow_args implements TBase<removeRow_args._Fields>, java.io.Serializable, Cloneable, Comparable<removeRow_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("removeRow_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_KEY_FIELD_DESC = new TField("rowKey", TType.STRING, (short)2);

    public String tableName;
    public String rowKey;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TABLE_NAME((short)1, "tableName"),
      ROW_KEY((short)2, "rowKey");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.ROW_KEY, new FieldMetaData("rowKey", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(removeRow_args.class, metaDataMap);
    }

    public removeRow_args() {
    }

    public removeRow_args(
      String tableName,
      String rowKey)
    {
      this();
      this.tableName = tableName;
      this.rowKey = rowKey;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public removeRow_args(removeRow_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRowKey()) {
        this.rowKey = other.rowKey;
      }
    }

    public removeRow_args deepCopy() {
      return new removeRow_args(this);
    }

    @Deprecated
    public removeRow_args clone() {
      return new removeRow_args(this);
    }

    public String getTableName() {
      return this.tableName;
    }

    public removeRow_args setTableName(String tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public String getRowKey() {
      return this.rowKey;
    }

    public removeRow_args setRowKey(String rowKey) {
      this.rowKey = rowKey;
      return this;
    }

    public void unsetRowKey() {
      this.rowKey = null;
    }

    /** Returns true if field rowKey is set (has been asigned a value) and false otherwise */
    public boolean isSetRowKey() {
      return this.rowKey != null;
    }

    public void setRowKeyIsSet(boolean value) {
      if (!value) {
        this.rowKey = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((String)value);
        }
        break;

      case ROW_KEY:
        if (value == null) {
          unsetRowKey();
        } else {
          setRowKey((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW_KEY:
        return getRowKey();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW_KEY:
        return isSetRowKey();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof removeRow_args)
        return this.equals((removeRow_args)that);
      return false;
    }

    public boolean equals(removeRow_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_rowKey = true && this.isSetRowKey();
      boolean that_present_rowKey = true && that.isSetRowKey();
      if (this_present_rowKey || that_present_rowKey) {
        if (!(this_present_rowKey && that_present_rowKey))
          return false;
        if (!this.rowKey.equals(that.rowKey))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(removeRow_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      removeRow_args typedOther = (removeRow_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tableName, typedOther.tableName);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetRowKey()).compareTo(isSetRowKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(rowKey, typedOther.rowKey);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TABLE_NAME:
              if (field.type == TType.STRING) {
                this.tableName = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case ROW_KEY:
              if (field.type == TType.STRING) {
                this.rowKey = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.rowKey != null) {
        oprot.writeFieldBegin(ROW_KEY_FIELD_DESC);
        oprot.writeString(this.rowKey);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("removeRow_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("rowKey:");
      if (this.rowKey == null) {
        sb.append("null");
      } else {
        sb.append(this.rowKey);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class removeRow_result implements TBase<removeRow_result._Fields>, java.io.Serializable, Cloneable, Comparable<removeRow_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("removeRow_result");

    private static final TField TIOE_FIELD_DESC = new TField("tioe", TType.STRUCT, (short)1);

    public ThriftIOException tioe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TIOE((short)1, "tioe");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TIOE, new FieldMetaData("tioe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(removeRow_result.class, metaDataMap);
    }

    public removeRow_result() {
    }

    public removeRow_result(
      ThriftIOException tioe)
    {
      this();
      this.tioe = tioe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public removeRow_result(removeRow_result other) {
      if (other.isSetTioe()) {
        this.tioe = new ThriftIOException(other.tioe);
      }
    }

    public removeRow_result deepCopy() {
      return new removeRow_result(this);
    }

    @Deprecated
    public removeRow_result clone() {
      return new removeRow_result(this);
    }

    public ThriftIOException getTioe() {
      return this.tioe;
    }

    public removeRow_result setTioe(ThriftIOException tioe) {
      this.tioe = tioe;
      return this;
    }

    public void unsetTioe() {
      this.tioe = null;
    }

    /** Returns true if field tioe is set (has been asigned a value) and false otherwise */
    public boolean isSetTioe() {
      return this.tioe != null;
    }

    public void setTioeIsSet(boolean value) {
      if (!value) {
        this.tioe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TIOE:
        if (value == null) {
          unsetTioe();
        } else {
          setTioe((ThriftIOException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TIOE:
        return getTioe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TIOE:
        return isSetTioe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof removeRow_result)
        return this.equals((removeRow_result)that);
      return false;
    }

    public boolean equals(removeRow_result that) {
      if (that == null)
        return false;

      boolean this_present_tioe = true && this.isSetTioe();
      boolean that_present_tioe = true && that.isSetTioe();
      if (this_present_tioe || that_present_tioe) {
        if (!(this_present_tioe && that_present_tioe))
          return false;
        if (!this.tioe.equals(that.tioe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(removeRow_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      removeRow_result typedOther = (removeRow_result)other;

      lastComparison = Boolean.valueOf(isSetTioe()).compareTo(isSetTioe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tioe, typedOther.tioe);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TIOE:
              if (field.type == TType.STRUCT) {
                this.tioe = new ThriftIOException();
                this.tioe.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetTioe()) {
        oprot.writeFieldBegin(TIOE_FIELD_DESC);
        this.tioe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("removeRow_result(");
      boolean first = true;

      sb.append("tioe:");
      if (this.tioe == null) {
        sb.append("null");
      } else {
        sb.append(this.tioe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class removeRowWithTime_args implements TBase<removeRowWithTime_args._Fields>, java.io.Serializable, Cloneable, Comparable<removeRowWithTime_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("removeRowWithTime_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_KEY_FIELD_DESC = new TField("rowKey", TType.STRING, (short)2);
    private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.STRING, (short)3);

    public String tableName;
    public String rowKey;
    public String timestamp;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TABLE_NAME((short)1, "tableName"),
      ROW_KEY((short)2, "rowKey"),
      TIMESTAMP((short)3, "timestamp");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.ROW_KEY, new FieldMetaData("rowKey", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(removeRowWithTime_args.class, metaDataMap);
    }

    public removeRowWithTime_args() {
    }

    public removeRowWithTime_args(
      String tableName,
      String rowKey,
      String timestamp)
    {
      this();
      this.tableName = tableName;
      this.rowKey = rowKey;
      this.timestamp = timestamp;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public removeRowWithTime_args(removeRowWithTime_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRowKey()) {
        this.rowKey = other.rowKey;
      }
      if (other.isSetTimestamp()) {
        this.timestamp = other.timestamp;
      }
    }

    public removeRowWithTime_args deepCopy() {
      return new removeRowWithTime_args(this);
    }

    @Deprecated
    public removeRowWithTime_args clone() {
      return new removeRowWithTime_args(this);
    }

    public String getTableName() {
      return this.tableName;
    }

    public removeRowWithTime_args setTableName(String tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public String getRowKey() {
      return this.rowKey;
    }

    public removeRowWithTime_args setRowKey(String rowKey) {
      this.rowKey = rowKey;
      return this;
    }

    public void unsetRowKey() {
      this.rowKey = null;
    }

    /** Returns true if field rowKey is set (has been asigned a value) and false otherwise */
    public boolean isSetRowKey() {
      return this.rowKey != null;
    }

    public void setRowKeyIsSet(boolean value) {
      if (!value) {
        this.rowKey = null;
      }
    }

    public String getTimestamp() {
      return this.timestamp;
    }

    public removeRowWithTime_args setTimestamp(String timestamp) {
      this.timestamp = timestamp;
      return this;
    }

    public void unsetTimestamp() {
      this.timestamp = null;
    }

    /** Returns true if field timestamp is set (has been asigned a value) and false otherwise */
    public boolean isSetTimestamp() {
      return this.timestamp != null;
    }

    public void setTimestampIsSet(boolean value) {
      if (!value) {
        this.timestamp = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((String)value);
        }
        break;

      case ROW_KEY:
        if (value == null) {
          unsetRowKey();
        } else {
          setRowKey((String)value);
        }
        break;

      case TIMESTAMP:
        if (value == null) {
          unsetTimestamp();
        } else {
          setTimestamp((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW_KEY:
        return getRowKey();

      case TIMESTAMP:
        return getTimestamp();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW_KEY:
        return isSetRowKey();
      case TIMESTAMP:
        return isSetTimestamp();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof removeRowWithTime_args)
        return this.equals((removeRowWithTime_args)that);
      return false;
    }

    public boolean equals(removeRowWithTime_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_rowKey = true && this.isSetRowKey();
      boolean that_present_rowKey = true && that.isSetRowKey();
      if (this_present_rowKey || that_present_rowKey) {
        if (!(this_present_rowKey && that_present_rowKey))
          return false;
        if (!this.rowKey.equals(that.rowKey))
          return false;
      }

      boolean this_present_timestamp = true && this.isSetTimestamp();
      boolean that_present_timestamp = true && that.isSetTimestamp();
      if (this_present_timestamp || that_present_timestamp) {
        if (!(this_present_timestamp && that_present_timestamp))
          return false;
        if (!this.timestamp.equals(that.timestamp))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(removeRowWithTime_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      removeRowWithTime_args typedOther = (removeRowWithTime_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tableName, typedOther.tableName);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetRowKey()).compareTo(isSetRowKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(rowKey, typedOther.rowKey);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(isSetTimestamp());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(timestamp, typedOther.timestamp);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TABLE_NAME:
              if (field.type == TType.STRING) {
                this.tableName = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case ROW_KEY:
              if (field.type == TType.STRING) {
                this.rowKey = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case TIMESTAMP:
              if (field.type == TType.STRING) {
                this.timestamp = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.rowKey != null) {
        oprot.writeFieldBegin(ROW_KEY_FIELD_DESC);
        oprot.writeString(this.rowKey);
        oprot.writeFieldEnd();
      }
      if (this.timestamp != null) {
        oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
        oprot.writeString(this.timestamp);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("removeRowWithTime_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("rowKey:");
      if (this.rowKey == null) {
        sb.append("null");
      } else {
        sb.append(this.rowKey);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timestamp:");
      if (this.timestamp == null) {
        sb.append("null");
      } else {
        sb.append(this.timestamp);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class removeRowWithTime_result implements TBase<removeRowWithTime_result._Fields>, java.io.Serializable, Cloneable, Comparable<removeRowWithTime_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("removeRowWithTime_result");

    private static final TField TIOE_FIELD_DESC = new TField("tioe", TType.STRUCT, (short)1);

    public ThriftIOException tioe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TIOE((short)1, "tioe");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TIOE, new FieldMetaData("tioe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(removeRowWithTime_result.class, metaDataMap);
    }

    public removeRowWithTime_result() {
    }

    public removeRowWithTime_result(
      ThriftIOException tioe)
    {
      this();
      this.tioe = tioe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public removeRowWithTime_result(removeRowWithTime_result other) {
      if (other.isSetTioe()) {
        this.tioe = new ThriftIOException(other.tioe);
      }
    }

    public removeRowWithTime_result deepCopy() {
      return new removeRowWithTime_result(this);
    }

    @Deprecated
    public removeRowWithTime_result clone() {
      return new removeRowWithTime_result(this);
    }

    public ThriftIOException getTioe() {
      return this.tioe;
    }

    public removeRowWithTime_result setTioe(ThriftIOException tioe) {
      this.tioe = tioe;
      return this;
    }

    public void unsetTioe() {
      this.tioe = null;
    }

    /** Returns true if field tioe is set (has been asigned a value) and false otherwise */
    public boolean isSetTioe() {
      return this.tioe != null;
    }

    public void setTioeIsSet(boolean value) {
      if (!value) {
        this.tioe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TIOE:
        if (value == null) {
          unsetTioe();
        } else {
          setTioe((ThriftIOException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TIOE:
        return getTioe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TIOE:
        return isSetTioe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof removeRowWithTime_result)
        return this.equals((removeRowWithTime_result)that);
      return false;
    }

    public boolean equals(removeRowWithTime_result that) {
      if (that == null)
        return false;

      boolean this_present_tioe = true && this.isSetTioe();
      boolean that_present_tioe = true && that.isSetTioe();
      if (this_present_tioe || that_present_tioe) {
        if (!(this_present_tioe && that_present_tioe))
          return false;
        if (!this.tioe.equals(that.tioe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(removeRowWithTime_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      removeRowWithTime_result typedOther = (removeRowWithTime_result)other;

      lastComparison = Boolean.valueOf(isSetTioe()).compareTo(isSetTioe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tioe, typedOther.tioe);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TIOE:
              if (field.type == TType.STRUCT) {
                this.tioe = new ThriftIOException();
                this.tioe.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetTioe()) {
        oprot.writeFieldBegin(TIOE_FIELD_DESC);
        this.tioe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("removeRowWithTime_result(");
      boolean first = true;

      sb.append("tioe:");
      if (this.tioe == null) {
        sb.append("null");
      } else {
        sb.append(this.tioe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class remove_args implements TBase<remove_args._Fields>, java.io.Serializable, Cloneable, Comparable<remove_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("remove_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_KEY_FIELD_DESC = new TField("rowKey", TType.STRING, (short)2);
    private static final TField COLUMN_NAME_FIELD_DESC = new TField("columnName", TType.STRING, (short)3);
    private static final TField CELL_KEY_FIELD_DESC = new TField("cellKey", TType.STRING, (short)4);

    public String tableName;
    public String rowKey;
    public String columnName;
    public String cellKey;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TABLE_NAME((short)1, "tableName"),
      ROW_KEY((short)2, "rowKey"),
      COLUMN_NAME((short)3, "columnName"),
      CELL_KEY((short)4, "cellKey");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.ROW_KEY, new FieldMetaData("rowKey", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.COLUMN_NAME, new FieldMetaData("columnName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.CELL_KEY, new FieldMetaData("cellKey", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(remove_args.class, metaDataMap);
    }

    public remove_args() {
    }

    public remove_args(
      String tableName,
      String rowKey,
      String columnName,
      String cellKey)
    {
      this();
      this.tableName = tableName;
      this.rowKey = rowKey;
      this.columnName = columnName;
      this.cellKey = cellKey;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public remove_args(remove_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRowKey()) {
        this.rowKey = other.rowKey;
      }
      if (other.isSetColumnName()) {
        this.columnName = other.columnName;
      }
      if (other.isSetCellKey()) {
        this.cellKey = other.cellKey;
      }
    }

    public remove_args deepCopy() {
      return new remove_args(this);
    }

    @Deprecated
    public remove_args clone() {
      return new remove_args(this);
    }

    public String getTableName() {
      return this.tableName;
    }

    public remove_args setTableName(String tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public String getRowKey() {
      return this.rowKey;
    }

    public remove_args setRowKey(String rowKey) {
      this.rowKey = rowKey;
      return this;
    }

    public void unsetRowKey() {
      this.rowKey = null;
    }

    /** Returns true if field rowKey is set (has been asigned a value) and false otherwise */
    public boolean isSetRowKey() {
      return this.rowKey != null;
    }

    public void setRowKeyIsSet(boolean value) {
      if (!value) {
        this.rowKey = null;
      }
    }

    public String getColumnName() {
      return this.columnName;
    }

    public remove_args setColumnName(String columnName) {
      this.columnName = columnName;
      return this;
    }

    public void unsetColumnName() {
      this.columnName = null;
    }

    /** Returns true if field columnName is set (has been asigned a value) and false otherwise */
    public boolean isSetColumnName() {
      return this.columnName != null;
    }

    public void setColumnNameIsSet(boolean value) {
      if (!value) {
        this.columnName = null;
      }
    }

    public String getCellKey() {
      return this.cellKey;
    }

    public remove_args setCellKey(String cellKey) {
      this.cellKey = cellKey;
      return this;
    }

    public void unsetCellKey() {
      this.cellKey = null;
    }

    /** Returns true if field cellKey is set (has been asigned a value) and false otherwise */
    public boolean isSetCellKey() {
      return this.cellKey != null;
    }

    public void setCellKeyIsSet(boolean value) {
      if (!value) {
        this.cellKey = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((String)value);
        }
        break;

      case ROW_KEY:
        if (value == null) {
          unsetRowKey();
        } else {
          setRowKey((String)value);
        }
        break;

      case COLUMN_NAME:
        if (value == null) {
          unsetColumnName();
        } else {
          setColumnName((String)value);
        }
        break;

      case CELL_KEY:
        if (value == null) {
          unsetCellKey();
        } else {
          setCellKey((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW_KEY:
        return getRowKey();

      case COLUMN_NAME:
        return getColumnName();

      case CELL_KEY:
        return getCellKey();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW_KEY:
        return isSetRowKey();
      case COLUMN_NAME:
        return isSetColumnName();
      case CELL_KEY:
        return isSetCellKey();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof remove_args)
        return this.equals((remove_args)that);
      return false;
    }

    public boolean equals(remove_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_rowKey = true && this.isSetRowKey();
      boolean that_present_rowKey = true && that.isSetRowKey();
      if (this_present_rowKey || that_present_rowKey) {
        if (!(this_present_rowKey && that_present_rowKey))
          return false;
        if (!this.rowKey.equals(that.rowKey))
          return false;
      }

      boolean this_present_columnName = true && this.isSetColumnName();
      boolean that_present_columnName = true && that.isSetColumnName();
      if (this_present_columnName || that_present_columnName) {
        if (!(this_present_columnName && that_present_columnName))
          return false;
        if (!this.columnName.equals(that.columnName))
          return false;
      }

      boolean this_present_cellKey = true && this.isSetCellKey();
      boolean that_present_cellKey = true && that.isSetCellKey();
      if (this_present_cellKey || that_present_cellKey) {
        if (!(this_present_cellKey && that_present_cellKey))
          return false;
        if (!this.cellKey.equals(that.cellKey))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(remove_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      remove_args typedOther = (remove_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tableName, typedOther.tableName);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetRowKey()).compareTo(isSetRowKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(rowKey, typedOther.rowKey);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetColumnName()).compareTo(isSetColumnName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(columnName, typedOther.columnName);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetCellKey()).compareTo(isSetCellKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(cellKey, typedOther.cellKey);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TABLE_NAME:
              if (field.type == TType.STRING) {
                this.tableName = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case ROW_KEY:
              if (field.type == TType.STRING) {
                this.rowKey = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case COLUMN_NAME:
              if (field.type == TType.STRING) {
                this.columnName = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case CELL_KEY:
              if (field.type == TType.STRING) {
                this.cellKey = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.rowKey != null) {
        oprot.writeFieldBegin(ROW_KEY_FIELD_DESC);
        oprot.writeString(this.rowKey);
        oprot.writeFieldEnd();
      }
      if (this.columnName != null) {
        oprot.writeFieldBegin(COLUMN_NAME_FIELD_DESC);
        oprot.writeString(this.columnName);
        oprot.writeFieldEnd();
      }
      if (this.cellKey != null) {
        oprot.writeFieldBegin(CELL_KEY_FIELD_DESC);
        oprot.writeString(this.cellKey);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("remove_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("rowKey:");
      if (this.rowKey == null) {
        sb.append("null");
      } else {
        sb.append(this.rowKey);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("columnName:");
      if (this.columnName == null) {
        sb.append("null");
      } else {
        sb.append(this.columnName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("cellKey:");
      if (this.cellKey == null) {
        sb.append("null");
      } else {
        sb.append(this.cellKey);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class remove_result implements TBase<remove_result._Fields>, java.io.Serializable, Cloneable, Comparable<remove_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("remove_result");

    private static final TField TIOE_FIELD_DESC = new TField("tioe", TType.STRUCT, (short)1);

    public ThriftIOException tioe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TIOE((short)1, "tioe");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TIOE, new FieldMetaData("tioe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(remove_result.class, metaDataMap);
    }

    public remove_result() {
    }

    public remove_result(
      ThriftIOException tioe)
    {
      this();
      this.tioe = tioe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public remove_result(remove_result other) {
      if (other.isSetTioe()) {
        this.tioe = new ThriftIOException(other.tioe);
      }
    }

    public remove_result deepCopy() {
      return new remove_result(this);
    }

    @Deprecated
    public remove_result clone() {
      return new remove_result(this);
    }

    public ThriftIOException getTioe() {
      return this.tioe;
    }

    public remove_result setTioe(ThriftIOException tioe) {
      this.tioe = tioe;
      return this;
    }

    public void unsetTioe() {
      this.tioe = null;
    }

    /** Returns true if field tioe is set (has been asigned a value) and false otherwise */
    public boolean isSetTioe() {
      return this.tioe != null;
    }

    public void setTioeIsSet(boolean value) {
      if (!value) {
        this.tioe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TIOE:
        if (value == null) {
          unsetTioe();
        } else {
          setTioe((ThriftIOException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TIOE:
        return getTioe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TIOE:
        return isSetTioe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof remove_result)
        return this.equals((remove_result)that);
      return false;
    }

    public boolean equals(remove_result that) {
      if (that == null)
        return false;

      boolean this_present_tioe = true && this.isSetTioe();
      boolean that_present_tioe = true && that.isSetTioe();
      if (this_present_tioe || that_present_tioe) {
        if (!(this_present_tioe && that_present_tioe))
          return false;
        if (!this.tioe.equals(that.tioe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(remove_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      remove_result typedOther = (remove_result)other;

      lastComparison = Boolean.valueOf(isSetTioe()).compareTo(isSetTioe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tioe, typedOther.tioe);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TIOE:
              if (field.type == TType.STRUCT) {
                this.tioe = new ThriftIOException();
                this.tioe.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetTioe()) {
        oprot.writeFieldBegin(TIOE_FIELD_DESC);
        this.tioe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("remove_result(");
      boolean first = true;

      sb.append("tioe:");
      if (this.tioe == null) {
        sb.append("null");
      } else {
        sb.append(this.tioe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class hasValue_args implements TBase<hasValue_args._Fields>, java.io.Serializable, Cloneable, Comparable<hasValue_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("hasValue_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField COLUMN_NAME_FIELD_DESC = new TField("columnName", TType.STRING, (short)2);
    private static final TField ROW_KEY_FIELD_DESC = new TField("rowKey", TType.STRING, (short)3);

    public String tableName;
    public String columnName;
    public String rowKey;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TABLE_NAME((short)1, "tableName"),
      COLUMN_NAME((short)2, "columnName"),
      ROW_KEY((short)3, "rowKey");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.COLUMN_NAME, new FieldMetaData("columnName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.ROW_KEY, new FieldMetaData("rowKey", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(hasValue_args.class, metaDataMap);
    }

    public hasValue_args() {
    }

    public hasValue_args(
      String tableName,
      String columnName,
      String rowKey)
    {
      this();
      this.tableName = tableName;
      this.columnName = columnName;
      this.rowKey = rowKey;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public hasValue_args(hasValue_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetColumnName()) {
        this.columnName = other.columnName;
      }
      if (other.isSetRowKey()) {
        this.rowKey = other.rowKey;
      }
    }

    public hasValue_args deepCopy() {
      return new hasValue_args(this);
    }

    @Deprecated
    public hasValue_args clone() {
      return new hasValue_args(this);
    }

    public String getTableName() {
      return this.tableName;
    }

    public hasValue_args setTableName(String tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public String getColumnName() {
      return this.columnName;
    }

    public hasValue_args setColumnName(String columnName) {
      this.columnName = columnName;
      return this;
    }

    public void unsetColumnName() {
      this.columnName = null;
    }

    /** Returns true if field columnName is set (has been asigned a value) and false otherwise */
    public boolean isSetColumnName() {
      return this.columnName != null;
    }

    public void setColumnNameIsSet(boolean value) {
      if (!value) {
        this.columnName = null;
      }
    }

    public String getRowKey() {
      return this.rowKey;
    }

    public hasValue_args setRowKey(String rowKey) {
      this.rowKey = rowKey;
      return this;
    }

    public void unsetRowKey() {
      this.rowKey = null;
    }

    /** Returns true if field rowKey is set (has been asigned a value) and false otherwise */
    public boolean isSetRowKey() {
      return this.rowKey != null;
    }

    public void setRowKeyIsSet(boolean value) {
      if (!value) {
        this.rowKey = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((String)value);
        }
        break;

      case COLUMN_NAME:
        if (value == null) {
          unsetColumnName();
        } else {
          setColumnName((String)value);
        }
        break;

      case ROW_KEY:
        if (value == null) {
          unsetRowKey();
        } else {
          setRowKey((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case COLUMN_NAME:
        return getColumnName();

      case ROW_KEY:
        return getRowKey();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case COLUMN_NAME:
        return isSetColumnName();
      case ROW_KEY:
        return isSetRowKey();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof hasValue_args)
        return this.equals((hasValue_args)that);
      return false;
    }

    public boolean equals(hasValue_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_columnName = true && this.isSetColumnName();
      boolean that_present_columnName = true && that.isSetColumnName();
      if (this_present_columnName || that_present_columnName) {
        if (!(this_present_columnName && that_present_columnName))
          return false;
        if (!this.columnName.equals(that.columnName))
          return false;
      }

      boolean this_present_rowKey = true && this.isSetRowKey();
      boolean that_present_rowKey = true && that.isSetRowKey();
      if (this_present_rowKey || that_present_rowKey) {
        if (!(this_present_rowKey && that_present_rowKey))
          return false;
        if (!this.rowKey.equals(that.rowKey))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(hasValue_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      hasValue_args typedOther = (hasValue_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tableName, typedOther.tableName);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetColumnName()).compareTo(isSetColumnName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(columnName, typedOther.columnName);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetRowKey()).compareTo(isSetRowKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(rowKey, typedOther.rowKey);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TABLE_NAME:
              if (field.type == TType.STRING) {
                this.tableName = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case COLUMN_NAME:
              if (field.type == TType.STRING) {
                this.columnName = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case ROW_KEY:
              if (field.type == TType.STRING) {
                this.rowKey = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.columnName != null) {
        oprot.writeFieldBegin(COLUMN_NAME_FIELD_DESC);
        oprot.writeString(this.columnName);
        oprot.writeFieldEnd();
      }
      if (this.rowKey != null) {
        oprot.writeFieldBegin(ROW_KEY_FIELD_DESC);
        oprot.writeString(this.rowKey);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("hasValue_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("columnName:");
      if (this.columnName == null) {
        sb.append("null");
      } else {
        sb.append(this.columnName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("rowKey:");
      if (this.rowKey == null) {
        sb.append("null");
      } else {
        sb.append(this.rowKey);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class hasValue_result implements TBase<hasValue_result._Fields>, java.io.Serializable, Cloneable, Comparable<hasValue_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("hasValue_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField TIOE_FIELD_DESC = new TField("tioe", TType.STRUCT, (short)1);

    public boolean success;
    public ThriftIOException tioe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      TIOE((short)1, "tioe");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      put(_Fields.TIOE, new FieldMetaData("tioe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(hasValue_result.class, metaDataMap);
    }

    public hasValue_result() {
    }

    public hasValue_result(
      boolean success,
      ThriftIOException tioe)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.tioe = tioe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public hasValue_result(hasValue_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetTioe()) {
        this.tioe = new ThriftIOException(other.tioe);
      }
    }

    public hasValue_result deepCopy() {
      return new hasValue_result(this);
    }

    @Deprecated
    public hasValue_result clone() {
      return new hasValue_result(this);
    }

    public boolean isSuccess() {
      return this.success;
    }

    public hasValue_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public ThriftIOException getTioe() {
      return this.tioe;
    }

    public hasValue_result setTioe(ThriftIOException tioe) {
      this.tioe = tioe;
      return this;
    }

    public void unsetTioe() {
      this.tioe = null;
    }

    /** Returns true if field tioe is set (has been asigned a value) and false otherwise */
    public boolean isSetTioe() {
      return this.tioe != null;
    }

    public void setTioeIsSet(boolean value) {
      if (!value) {
        this.tioe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case TIOE:
        if (value == null) {
          unsetTioe();
        } else {
          setTioe((ThriftIOException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case TIOE:
        return getTioe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case TIOE:
        return isSetTioe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof hasValue_result)
        return this.equals((hasValue_result)that);
      return false;
    }

    public boolean equals(hasValue_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_tioe = true && this.isSetTioe();
      boolean that_present_tioe = true && that.isSetTioe();
      if (this_present_tioe || that_present_tioe) {
        if (!(this_present_tioe && that_present_tioe))
          return false;
        if (!this.tioe.equals(that.tioe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(hasValue_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      hasValue_result typedOther = (hasValue_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetTioe()).compareTo(isSetTioe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tioe, typedOther.tioe);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case SUCCESS:
              if (field.type == TType.BOOL) {
                this.success = iprot.readBool();
                setSuccessIsSet(true);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case TIOE:
              if (field.type == TType.STRUCT) {
                this.tioe = new ThriftIOException();
                this.tioe.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetTioe()) {
        oprot.writeFieldBegin(TIOE_FIELD_DESC);
        this.tioe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("hasValue_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("tioe:");
      if (this.tioe == null) {
        sb.append("null");
      } else {
        sb.append(this.tioe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getValue_args implements TBase<getValue_args._Fields>, java.io.Serializable, Cloneable, Comparable<getValue_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getValue_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_KEY_FIELD_DESC = new TField("rowKey", TType.STRING, (short)2);
    private static final TField COLUMN_NAME_FIELD_DESC = new TField("columnName", TType.STRING, (short)3);
    private static final TField CELL_KEY_FIELD_DESC = new TField("cellKey", TType.STRING, (short)4);

    public String tableName;
    public String rowKey;
    public String columnName;
    public String cellKey;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TABLE_NAME((short)1, "tableName"),
      ROW_KEY((short)2, "rowKey"),
      COLUMN_NAME((short)3, "columnName"),
      CELL_KEY((short)4, "cellKey");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.ROW_KEY, new FieldMetaData("rowKey", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.COLUMN_NAME, new FieldMetaData("columnName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.CELL_KEY, new FieldMetaData("cellKey", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getValue_args.class, metaDataMap);
    }

    public getValue_args() {
    }

    public getValue_args(
      String tableName,
      String rowKey,
      String columnName,
      String cellKey)
    {
      this();
      this.tableName = tableName;
      this.rowKey = rowKey;
      this.columnName = columnName;
      this.cellKey = cellKey;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getValue_args(getValue_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRowKey()) {
        this.rowKey = other.rowKey;
      }
      if (other.isSetColumnName()) {
        this.columnName = other.columnName;
      }
      if (other.isSetCellKey()) {
        this.cellKey = other.cellKey;
      }
    }

    public getValue_args deepCopy() {
      return new getValue_args(this);
    }

    @Deprecated
    public getValue_args clone() {
      return new getValue_args(this);
    }

    public String getTableName() {
      return this.tableName;
    }

    public getValue_args setTableName(String tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public String getRowKey() {
      return this.rowKey;
    }

    public getValue_args setRowKey(String rowKey) {
      this.rowKey = rowKey;
      return this;
    }

    public void unsetRowKey() {
      this.rowKey = null;
    }

    /** Returns true if field rowKey is set (has been asigned a value) and false otherwise */
    public boolean isSetRowKey() {
      return this.rowKey != null;
    }

    public void setRowKeyIsSet(boolean value) {
      if (!value) {
        this.rowKey = null;
      }
    }

    public String getColumnName() {
      return this.columnName;
    }

    public getValue_args setColumnName(String columnName) {
      this.columnName = columnName;
      return this;
    }

    public void unsetColumnName() {
      this.columnName = null;
    }

    /** Returns true if field columnName is set (has been asigned a value) and false otherwise */
    public boolean isSetColumnName() {
      return this.columnName != null;
    }

    public void setColumnNameIsSet(boolean value) {
      if (!value) {
        this.columnName = null;
      }
    }

    public String getCellKey() {
      return this.cellKey;
    }

    public getValue_args setCellKey(String cellKey) {
      this.cellKey = cellKey;
      return this;
    }

    public void unsetCellKey() {
      this.cellKey = null;
    }

    /** Returns true if field cellKey is set (has been asigned a value) and false otherwise */
    public boolean isSetCellKey() {
      return this.cellKey != null;
    }

    public void setCellKeyIsSet(boolean value) {
      if (!value) {
        this.cellKey = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((String)value);
        }
        break;

      case ROW_KEY:
        if (value == null) {
          unsetRowKey();
        } else {
          setRowKey((String)value);
        }
        break;

      case COLUMN_NAME:
        if (value == null) {
          unsetColumnName();
        } else {
          setColumnName((String)value);
        }
        break;

      case CELL_KEY:
        if (value == null) {
          unsetCellKey();
        } else {
          setCellKey((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW_KEY:
        return getRowKey();

      case COLUMN_NAME:
        return getColumnName();

      case CELL_KEY:
        return getCellKey();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW_KEY:
        return isSetRowKey();
      case COLUMN_NAME:
        return isSetColumnName();
      case CELL_KEY:
        return isSetCellKey();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getValue_args)
        return this.equals((getValue_args)that);
      return false;
    }

    public boolean equals(getValue_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_rowKey = true && this.isSetRowKey();
      boolean that_present_rowKey = true && that.isSetRowKey();
      if (this_present_rowKey || that_present_rowKey) {
        if (!(this_present_rowKey && that_present_rowKey))
          return false;
        if (!this.rowKey.equals(that.rowKey))
          return false;
      }

      boolean this_present_columnName = true && this.isSetColumnName();
      boolean that_present_columnName = true && that.isSetColumnName();
      if (this_present_columnName || that_present_columnName) {
        if (!(this_present_columnName && that_present_columnName))
          return false;
        if (!this.columnName.equals(that.columnName))
          return false;
      }

      boolean this_present_cellKey = true && this.isSetCellKey();
      boolean that_present_cellKey = true && that.isSetCellKey();
      if (this_present_cellKey || that_present_cellKey) {
        if (!(this_present_cellKey && that_present_cellKey))
          return false;
        if (!this.cellKey.equals(that.cellKey))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getValue_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getValue_args typedOther = (getValue_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tableName, typedOther.tableName);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetRowKey()).compareTo(isSetRowKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(rowKey, typedOther.rowKey);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetColumnName()).compareTo(isSetColumnName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(columnName, typedOther.columnName);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetCellKey()).compareTo(isSetCellKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(cellKey, typedOther.cellKey);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TABLE_NAME:
              if (field.type == TType.STRING) {
                this.tableName = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case ROW_KEY:
              if (field.type == TType.STRING) {
                this.rowKey = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case COLUMN_NAME:
              if (field.type == TType.STRING) {
                this.columnName = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case CELL_KEY:
              if (field.type == TType.STRING) {
                this.cellKey = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.rowKey != null) {
        oprot.writeFieldBegin(ROW_KEY_FIELD_DESC);
        oprot.writeString(this.rowKey);
        oprot.writeFieldEnd();
      }
      if (this.columnName != null) {
        oprot.writeFieldBegin(COLUMN_NAME_FIELD_DESC);
        oprot.writeString(this.columnName);
        oprot.writeFieldEnd();
      }
      if (this.cellKey != null) {
        oprot.writeFieldBegin(CELL_KEY_FIELD_DESC);
        oprot.writeString(this.cellKey);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getValue_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("rowKey:");
      if (this.rowKey == null) {
        sb.append("null");
      } else {
        sb.append(this.rowKey);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("columnName:");
      if (this.columnName == null) {
        sb.append("null");
      } else {
        sb.append(this.columnName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("cellKey:");
      if (this.cellKey == null) {
        sb.append("null");
      } else {
        sb.append(this.cellKey);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getValue_result implements TBase<getValue_result._Fields>, java.io.Serializable, Cloneable, Comparable<getValue_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("getValue_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
    private static final TField TIOE_FIELD_DESC = new TField("tioe", TType.STRUCT, (short)1);

    public byte[] success;
    public ThriftIOException tioe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      TIOE((short)1, "tioe");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.TIOE, new FieldMetaData("tioe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getValue_result.class, metaDataMap);
    }

    public getValue_result() {
    }

    public getValue_result(
      byte[] success,
      ThriftIOException tioe)
    {
      this();
      this.success = success;
      this.tioe = tioe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getValue_result(getValue_result other) {
      if (other.isSetSuccess()) {
        this.success = new byte[other.success.length];
        System.arraycopy(other.success, 0, success, 0, other.success.length);
      }
      if (other.isSetTioe()) {
        this.tioe = new ThriftIOException(other.tioe);
      }
    }

    public getValue_result deepCopy() {
      return new getValue_result(this);
    }

    @Deprecated
    public getValue_result clone() {
      return new getValue_result(this);
    }

    public byte[] getSuccess() {
      return this.success;
    }

    public getValue_result setSuccess(byte[] success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThriftIOException getTioe() {
      return this.tioe;
    }

    public getValue_result setTioe(ThriftIOException tioe) {
      this.tioe = tioe;
      return this;
    }

    public void unsetTioe() {
      this.tioe = null;
    }

    /** Returns true if field tioe is set (has been asigned a value) and false otherwise */
    public boolean isSetTioe() {
      return this.tioe != null;
    }

    public void setTioeIsSet(boolean value) {
      if (!value) {
        this.tioe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((byte[])value);
        }
        break;

      case TIOE:
        if (value == null) {
          unsetTioe();
        } else {
          setTioe((ThriftIOException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case TIOE:
        return getTioe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case TIOE:
        return isSetTioe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getValue_result)
        return this.equals((getValue_result)that);
      return false;
    }

    public boolean equals(getValue_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!java.util.Arrays.equals(this.success, that.success))
          return false;
      }

      boolean this_present_tioe = true && this.isSetTioe();
      boolean that_present_tioe = true && that.isSetTioe();
      if (this_present_tioe || that_present_tioe) {
        if (!(this_present_tioe && that_present_tioe))
          return false;
        if (!this.tioe.equals(that.tioe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getValue_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getValue_result typedOther = (getValue_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetTioe()).compareTo(isSetTioe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tioe, typedOther.tioe);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case SUCCESS:
              if (field.type == TType.STRING) {
                this.success = iprot.readBinary();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case TIOE:
              if (field.type == TType.STRUCT) {
                this.tioe = new ThriftIOException();
                this.tioe.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBinary(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetTioe()) {
        oprot.writeFieldBegin(TIOE_FIELD_DESC);
        this.tioe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getValue_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
          int __success_size = Math.min(this.success.length, 128);
          for (int i = 0; i < __success_size; i++) {
            if (i != 0) sb.append(" ");
            sb.append(Integer.toHexString(this.success[i]).length() > 1 ? Integer.toHexString(this.success[i]).substring(Integer.toHexString(this.success[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.success[i]).toUpperCase());
          }
          if (this.success.length > 128) sb.append(" ...");
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tioe:");
      if (this.tioe == null) {
        sb.append("null");
      } else {
        sb.append(this.tioe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_args implements TBase<get_args._Fields>, java.io.Serializable, Cloneable, Comparable<get_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("get_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_KEY_FIELD_DESC = new TField("rowKey", TType.STRING, (short)2);

    public String tableName;
    public String rowKey;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TABLE_NAME((short)1, "tableName"),
      ROW_KEY((short)2, "rowKey");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.ROW_KEY, new FieldMetaData("rowKey", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_args.class, metaDataMap);
    }

    public get_args() {
    }

    public get_args(
      String tableName,
      String rowKey)
    {
      this();
      this.tableName = tableName;
      this.rowKey = rowKey;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_args(get_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRowKey()) {
        this.rowKey = other.rowKey;
      }
    }

    public get_args deepCopy() {
      return new get_args(this);
    }

    @Deprecated
    public get_args clone() {
      return new get_args(this);
    }

    public String getTableName() {
      return this.tableName;
    }

    public get_args setTableName(String tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public String getRowKey() {
      return this.rowKey;
    }

    public get_args setRowKey(String rowKey) {
      this.rowKey = rowKey;
      return this;
    }

    public void unsetRowKey() {
      this.rowKey = null;
    }

    /** Returns true if field rowKey is set (has been asigned a value) and false otherwise */
    public boolean isSetRowKey() {
      return this.rowKey != null;
    }

    public void setRowKeyIsSet(boolean value) {
      if (!value) {
        this.rowKey = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((String)value);
        }
        break;

      case ROW_KEY:
        if (value == null) {
          unsetRowKey();
        } else {
          setRowKey((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW_KEY:
        return getRowKey();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW_KEY:
        return isSetRowKey();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_args)
        return this.equals((get_args)that);
      return false;
    }

    public boolean equals(get_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_rowKey = true && this.isSetRowKey();
      boolean that_present_rowKey = true && that.isSetRowKey();
      if (this_present_rowKey || that_present_rowKey) {
        if (!(this_present_rowKey && that_present_rowKey))
          return false;
        if (!this.rowKey.equals(that.rowKey))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_args typedOther = (get_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tableName, typedOther.tableName);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetRowKey()).compareTo(isSetRowKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(rowKey, typedOther.rowKey);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TABLE_NAME:
              if (field.type == TType.STRING) {
                this.tableName = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case ROW_KEY:
              if (field.type == TType.STRING) {
                this.rowKey = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.rowKey != null) {
        oprot.writeFieldBegin(ROW_KEY_FIELD_DESC);
        oprot.writeString(this.rowKey);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("rowKey:");
      if (this.rowKey == null) {
        sb.append("null");
      } else {
        sb.append(this.rowKey);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_result implements TBase<get_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField TIOE_FIELD_DESC = new TField("tioe", TType.STRUCT, (short)1);

    public ThriftRow success;
    public ThriftIOException tioe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      TIOE((short)1, "tioe");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ThriftRow.class)));
      put(_Fields.TIOE, new FieldMetaData("tioe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_result.class, metaDataMap);
    }

    public get_result() {
    }

    public get_result(
      ThriftRow success,
      ThriftIOException tioe)
    {
      this();
      this.success = success;
      this.tioe = tioe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_result(get_result other) {
      if (other.isSetSuccess()) {
        this.success = new ThriftRow(other.success);
      }
      if (other.isSetTioe()) {
        this.tioe = new ThriftIOException(other.tioe);
      }
    }

    public get_result deepCopy() {
      return new get_result(this);
    }

    @Deprecated
    public get_result clone() {
      return new get_result(this);
    }

    public ThriftRow getSuccess() {
      return this.success;
    }

    public get_result setSuccess(ThriftRow success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThriftIOException getTioe() {
      return this.tioe;
    }

    public get_result setTioe(ThriftIOException tioe) {
      this.tioe = tioe;
      return this;
    }

    public void unsetTioe() {
      this.tioe = null;
    }

    /** Returns true if field tioe is set (has been asigned a value) and false otherwise */
    public boolean isSetTioe() {
      return this.tioe != null;
    }

    public void setTioeIsSet(boolean value) {
      if (!value) {
        this.tioe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ThriftRow)value);
        }
        break;

      case TIOE:
        if (value == null) {
          unsetTioe();
        } else {
          setTioe((ThriftIOException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case TIOE:
        return getTioe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case TIOE:
        return isSetTioe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_result)
        return this.equals((get_result)that);
      return false;
    }

    public boolean equals(get_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_tioe = true && this.isSetTioe();
      boolean that_present_tioe = true && that.isSetTioe();
      if (this_present_tioe || that_present_tioe) {
        if (!(this_present_tioe && that_present_tioe))
          return false;
        if (!this.tioe.equals(that.tioe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case SUCCESS:
              if (field.type == TType.STRUCT) {
                this.success = new ThriftRow();
                this.success.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case TIOE:
              if (field.type == TType.STRUCT) {
                this.tioe = new ThriftIOException();
                this.tioe.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetTioe()) {
        oprot.writeFieldBegin(TIOE_FIELD_DESC);
        this.tioe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tioe:");
      if (this.tioe == null) {
        sb.append("null");
      } else {
        sb.append(this.tioe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getColumnRow_args implements TBase<getColumnRow_args._Fields>, java.io.Serializable, Cloneable, Comparable<getColumnRow_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getColumnRow_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ROW_KEY_FIELD_DESC = new TField("rowKey", TType.STRING, (short)2);
    private static final TField COLUMN_NAMES_FIELD_DESC = new TField("columnNames", TType.LIST, (short)3);

    public String tableName;
    public String rowKey;
    public List<String> columnNames;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TABLE_NAME((short)1, "tableName"),
      ROW_KEY((short)2, "rowKey"),
      COLUMN_NAMES((short)3, "columnNames");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.ROW_KEY, new FieldMetaData("rowKey", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.COLUMN_NAMES, new FieldMetaData("columnNames", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getColumnRow_args.class, metaDataMap);
    }

    public getColumnRow_args() {
    }

    public getColumnRow_args(
      String tableName,
      String rowKey,
      List<String> columnNames)
    {
      this();
      this.tableName = tableName;
      this.rowKey = rowKey;
      this.columnNames = columnNames;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getColumnRow_args(getColumnRow_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetRowKey()) {
        this.rowKey = other.rowKey;
      }
      if (other.isSetColumnNames()) {
        List<String> __this__columnNames = new ArrayList<String>();
        for (String other_element : other.columnNames) {
          __this__columnNames.add(other_element);
        }
        this.columnNames = __this__columnNames;
      }
    }

    public getColumnRow_args deepCopy() {
      return new getColumnRow_args(this);
    }

    @Deprecated
    public getColumnRow_args clone() {
      return new getColumnRow_args(this);
    }

    public String getTableName() {
      return this.tableName;
    }

    public getColumnRow_args setTableName(String tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public String getRowKey() {
      return this.rowKey;
    }

    public getColumnRow_args setRowKey(String rowKey) {
      this.rowKey = rowKey;
      return this;
    }

    public void unsetRowKey() {
      this.rowKey = null;
    }

    /** Returns true if field rowKey is set (has been asigned a value) and false otherwise */
    public boolean isSetRowKey() {
      return this.rowKey != null;
    }

    public void setRowKeyIsSet(boolean value) {
      if (!value) {
        this.rowKey = null;
      }
    }

    public int getColumnNamesSize() {
      return (this.columnNames == null) ? 0 : this.columnNames.size();
    }

    public java.util.Iterator<String> getColumnNamesIterator() {
      return (this.columnNames == null) ? null : this.columnNames.iterator();
    }

    public void addToColumnNames(String elem) {
      if (this.columnNames == null) {
        this.columnNames = new ArrayList<String>();
      }
      this.columnNames.add(elem);
    }

    public List<String> getColumnNames() {
      return this.columnNames;
    }

    public getColumnRow_args setColumnNames(List<String> columnNames) {
      this.columnNames = columnNames;
      return this;
    }

    public void unsetColumnNames() {
      this.columnNames = null;
    }

    /** Returns true if field columnNames is set (has been asigned a value) and false otherwise */
    public boolean isSetColumnNames() {
      return this.columnNames != null;
    }

    public void setColumnNamesIsSet(boolean value) {
      if (!value) {
        this.columnNames = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((String)value);
        }
        break;

      case ROW_KEY:
        if (value == null) {
          unsetRowKey();
        } else {
          setRowKey((String)value);
        }
        break;

      case COLUMN_NAMES:
        if (value == null) {
          unsetColumnNames();
        } else {
          setColumnNames((List<String>)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ROW_KEY:
        return getRowKey();

      case COLUMN_NAMES:
        return getColumnNames();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ROW_KEY:
        return isSetRowKey();
      case COLUMN_NAMES:
        return isSetColumnNames();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getColumnRow_args)
        return this.equals((getColumnRow_args)that);
      return false;
    }

    public boolean equals(getColumnRow_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_rowKey = true && this.isSetRowKey();
      boolean that_present_rowKey = true && that.isSetRowKey();
      if (this_present_rowKey || that_present_rowKey) {
        if (!(this_present_rowKey && that_present_rowKey))
          return false;
        if (!this.rowKey.equals(that.rowKey))
          return false;
      }

      boolean this_present_columnNames = true && this.isSetColumnNames();
      boolean that_present_columnNames = true && that.isSetColumnNames();
      if (this_present_columnNames || that_present_columnNames) {
        if (!(this_present_columnNames && that_present_columnNames))
          return false;
        if (!this.columnNames.equals(that.columnNames))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getColumnRow_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getColumnRow_args typedOther = (getColumnRow_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tableName, typedOther.tableName);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetRowKey()).compareTo(isSetRowKey());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(rowKey, typedOther.rowKey);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetColumnNames()).compareTo(isSetColumnNames());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(columnNames, typedOther.columnNames);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TABLE_NAME:
              if (field.type == TType.STRING) {
                this.tableName = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case ROW_KEY:
              if (field.type == TType.STRING) {
                this.rowKey = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case COLUMN_NAMES:
              if (field.type == TType.LIST) {
                {
                  TList _list21 = iprot.readListBegin();
                  this.columnNames = new ArrayList<String>(_list21.size);
                  for (int _i22 = 0; _i22 < _list21.size; ++_i22)
                  {
                    String _elem23;
                    _elem23 = iprot.readString();
                    this.columnNames.add(_elem23);
                  }
                  iprot.readListEnd();
                }
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.rowKey != null) {
        oprot.writeFieldBegin(ROW_KEY_FIELD_DESC);
        oprot.writeString(this.rowKey);
        oprot.writeFieldEnd();
      }
      if (this.columnNames != null) {
        oprot.writeFieldBegin(COLUMN_NAMES_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.columnNames.size()));
          for (String _iter24 : this.columnNames)
          {
            oprot.writeString(_iter24);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getColumnRow_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("rowKey:");
      if (this.rowKey == null) {
        sb.append("null");
      } else {
        sb.append(this.rowKey);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("columnNames:");
      if (this.columnNames == null) {
        sb.append("null");
      } else {
        sb.append(this.columnNames);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getColumnRow_result implements TBase<getColumnRow_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getColumnRow_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField TIOE_FIELD_DESC = new TField("tioe", TType.STRUCT, (short)1);

    public ThriftRow success;
    public ThriftIOException tioe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      TIOE((short)1, "tioe");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ThriftRow.class)));
      put(_Fields.TIOE, new FieldMetaData("tioe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getColumnRow_result.class, metaDataMap);
    }

    public getColumnRow_result() {
    }

    public getColumnRow_result(
      ThriftRow success,
      ThriftIOException tioe)
    {
      this();
      this.success = success;
      this.tioe = tioe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getColumnRow_result(getColumnRow_result other) {
      if (other.isSetSuccess()) {
        this.success = new ThriftRow(other.success);
      }
      if (other.isSetTioe()) {
        this.tioe = new ThriftIOException(other.tioe);
      }
    }

    public getColumnRow_result deepCopy() {
      return new getColumnRow_result(this);
    }

    @Deprecated
    public getColumnRow_result clone() {
      return new getColumnRow_result(this);
    }

    public ThriftRow getSuccess() {
      return this.success;
    }

    public getColumnRow_result setSuccess(ThriftRow success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThriftIOException getTioe() {
      return this.tioe;
    }

    public getColumnRow_result setTioe(ThriftIOException tioe) {
      this.tioe = tioe;
      return this;
    }

    public void unsetTioe() {
      this.tioe = null;
    }

    /** Returns true if field tioe is set (has been asigned a value) and false otherwise */
    public boolean isSetTioe() {
      return this.tioe != null;
    }

    public void setTioeIsSet(boolean value) {
      if (!value) {
        this.tioe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ThriftRow)value);
        }
        break;

      case TIOE:
        if (value == null) {
          unsetTioe();
        } else {
          setTioe((ThriftIOException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case TIOE:
        return getTioe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case TIOE:
        return isSetTioe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getColumnRow_result)
        return this.equals((getColumnRow_result)that);
      return false;
    }

    public boolean equals(getColumnRow_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_tioe = true && this.isSetTioe();
      boolean that_present_tioe = true && that.isSetTioe();
      if (this_present_tioe || that_present_tioe) {
        if (!(this_present_tioe && that_present_tioe))
          return false;
        if (!this.tioe.equals(that.tioe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case SUCCESS:
              if (field.type == TType.STRUCT) {
                this.success = new ThriftRow();
                this.success.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case TIOE:
              if (field.type == TType.STRUCT) {
                this.tioe = new ThriftIOException();
                this.tioe.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetTioe()) {
        oprot.writeFieldBegin(TIOE_FIELD_DESC);
        this.tioe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getColumnRow_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tioe:");
      if (this.tioe == null) {
        sb.append("null");
      } else {
        sb.append(this.tioe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createTable_args implements TBase<createTable_args._Fields>, java.io.Serializable, Cloneable, Comparable<createTable_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("createTable_args");

    private static final TField TABLE_SCHEMA_FIELD_DESC = new TField("tableSchema", TType.STRUCT, (short)1);

    public ThriftTableSchema tableSchema;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TABLE_SCHEMA((short)1, "tableSchema");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TABLE_SCHEMA, new FieldMetaData("tableSchema", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ThriftTableSchema.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(createTable_args.class, metaDataMap);
    }

    public createTable_args() {
    }

    public createTable_args(
      ThriftTableSchema tableSchema)
    {
      this();
      this.tableSchema = tableSchema;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createTable_args(createTable_args other) {
      if (other.isSetTableSchema()) {
        this.tableSchema = new ThriftTableSchema(other.tableSchema);
      }
    }

    public createTable_args deepCopy() {
      return new createTable_args(this);
    }

    @Deprecated
    public createTable_args clone() {
      return new createTable_args(this);
    }

    public ThriftTableSchema getTableSchema() {
      return this.tableSchema;
    }

    public createTable_args setTableSchema(ThriftTableSchema tableSchema) {
      this.tableSchema = tableSchema;
      return this;
    }

    public void unsetTableSchema() {
      this.tableSchema = null;
    }

    /** Returns true if field tableSchema is set (has been asigned a value) and false otherwise */
    public boolean isSetTableSchema() {
      return this.tableSchema != null;
    }

    public void setTableSchemaIsSet(boolean value) {
      if (!value) {
        this.tableSchema = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_SCHEMA:
        if (value == null) {
          unsetTableSchema();
        } else {
          setTableSchema((ThriftTableSchema)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_SCHEMA:
        return getTableSchema();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TABLE_SCHEMA:
        return isSetTableSchema();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createTable_args)
        return this.equals((createTable_args)that);
      return false;
    }

    public boolean equals(createTable_args that) {
      if (that == null)
        return false;

      boolean this_present_tableSchema = true && this.isSetTableSchema();
      boolean that_present_tableSchema = true && that.isSetTableSchema();
      if (this_present_tableSchema || that_present_tableSchema) {
        if (!(this_present_tableSchema && that_present_tableSchema))
          return false;
        if (!this.tableSchema.equals(that.tableSchema))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(createTable_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      createTable_args typedOther = (createTable_args)other;

      lastComparison = Boolean.valueOf(isSetTableSchema()).compareTo(isSetTableSchema());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tableSchema, typedOther.tableSchema);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TABLE_SCHEMA:
              if (field.type == TType.STRUCT) {
                this.tableSchema = new ThriftTableSchema();
                this.tableSchema.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableSchema != null) {
        oprot.writeFieldBegin(TABLE_SCHEMA_FIELD_DESC);
        this.tableSchema.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("createTable_args(");
      boolean first = true;

      sb.append("tableSchema:");
      if (this.tableSchema == null) {
        sb.append("null");
      } else {
        sb.append(this.tableSchema);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createTable_result implements TBase<createTable_result._Fields>, java.io.Serializable, Cloneable, Comparable<createTable_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("createTable_result");

    private static final TField TIOE_FIELD_DESC = new TField("tioe", TType.STRUCT, (short)1);

    public ThriftIOException tioe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TIOE((short)1, "tioe");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TIOE, new FieldMetaData("tioe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(createTable_result.class, metaDataMap);
    }

    public createTable_result() {
    }

    public createTable_result(
      ThriftIOException tioe)
    {
      this();
      this.tioe = tioe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createTable_result(createTable_result other) {
      if (other.isSetTioe()) {
        this.tioe = new ThriftIOException(other.tioe);
      }
    }

    public createTable_result deepCopy() {
      return new createTable_result(this);
    }

    @Deprecated
    public createTable_result clone() {
      return new createTable_result(this);
    }

    public ThriftIOException getTioe() {
      return this.tioe;
    }

    public createTable_result setTioe(ThriftIOException tioe) {
      this.tioe = tioe;
      return this;
    }

    public void unsetTioe() {
      this.tioe = null;
    }

    /** Returns true if field tioe is set (has been asigned a value) and false otherwise */
    public boolean isSetTioe() {
      return this.tioe != null;
    }

    public void setTioeIsSet(boolean value) {
      if (!value) {
        this.tioe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TIOE:
        if (value == null) {
          unsetTioe();
        } else {
          setTioe((ThriftIOException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TIOE:
        return getTioe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TIOE:
        return isSetTioe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createTable_result)
        return this.equals((createTable_result)that);
      return false;
    }

    public boolean equals(createTable_result that) {
      if (that == null)
        return false;

      boolean this_present_tioe = true && this.isSetTioe();
      boolean that_present_tioe = true && that.isSetTioe();
      if (this_present_tioe || that_present_tioe) {
        if (!(this_present_tioe && that_present_tioe))
          return false;
        if (!this.tioe.equals(that.tioe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(createTable_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      createTable_result typedOther = (createTable_result)other;

      lastComparison = Boolean.valueOf(isSetTioe()).compareTo(isSetTioe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tioe, typedOther.tioe);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TIOE:
              if (field.type == TType.STRUCT) {
                this.tioe = new ThriftIOException();
                this.tioe.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetTioe()) {
        oprot.writeFieldBegin(TIOE_FIELD_DESC);
        this.tioe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("createTable_result(");
      boolean first = true;

      sb.append("tioe:");
      if (this.tioe == null) {
        sb.append("null");
      } else {
        sb.append(this.tioe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class existsTable_args implements TBase<existsTable_args._Fields>, java.io.Serializable, Cloneable, Comparable<existsTable_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("existsTable_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);

    public String tableName;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TABLE_NAME((short)1, "tableName");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(existsTable_args.class, metaDataMap);
    }

    public existsTable_args() {
    }

    public existsTable_args(
      String tableName)
    {
      this();
      this.tableName = tableName;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public existsTable_args(existsTable_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
    }

    public existsTable_args deepCopy() {
      return new existsTable_args(this);
    }

    @Deprecated
    public existsTable_args clone() {
      return new existsTable_args(this);
    }

    public String getTableName() {
      return this.tableName;
    }

    public existsTable_args setTableName(String tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof existsTable_args)
        return this.equals((existsTable_args)that);
      return false;
    }

    public boolean equals(existsTable_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(existsTable_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      existsTable_args typedOther = (existsTable_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tableName, typedOther.tableName);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TABLE_NAME:
              if (field.type == TType.STRING) {
                this.tableName = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.tableName);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("existsTable_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class existsTable_result implements TBase<existsTable_result._Fields>, java.io.Serializable, Cloneable, Comparable<existsTable_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("existsTable_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField TIOE_FIELD_DESC = new TField("tioe", TType.STRUCT, (short)1);

    public boolean success;
    public ThriftIOException tioe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      TIOE((short)1, "tioe");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      put(_Fields.TIOE, new FieldMetaData("tioe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(existsTable_result.class, metaDataMap);
    }

    public existsTable_result() {
    }

    public existsTable_result(
      boolean success,
      ThriftIOException tioe)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.tioe = tioe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public existsTable_result(existsTable_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetTioe()) {
        this.tioe = new ThriftIOException(other.tioe);
      }
    }

    public existsTable_result deepCopy() {
      return new existsTable_result(this);
    }

    @Deprecated
    public existsTable_result clone() {
      return new existsTable_result(this);
    }

    public boolean isSuccess() {
      return this.success;
    }

    public existsTable_result setSuccess(boolean success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public ThriftIOException getTioe() {
      return this.tioe;
    }

    public existsTable_result setTioe(ThriftIOException tioe) {
      this.tioe = tioe;
      return this;
    }

    public void unsetTioe() {
      this.tioe = null;
    }

    /** Returns true if field tioe is set (has been asigned a value) and false otherwise */
    public boolean isSetTioe() {
      return this.tioe != null;
    }

    public void setTioeIsSet(boolean value) {
      if (!value) {
        this.tioe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Boolean)value);
        }
        break;

      case TIOE:
        if (value == null) {
          unsetTioe();
        } else {
          setTioe((ThriftIOException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case TIOE:
        return getTioe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case TIOE:
        return isSetTioe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof existsTable_result)
        return this.equals((existsTable_result)that);
      return false;
    }

    public boolean equals(existsTable_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_tioe = true && this.isSetTioe();
      boolean that_present_tioe = true && that.isSetTioe();
      if (this_present_tioe || that_present_tioe) {
        if (!(this_present_tioe && that_present_tioe))
          return false;
        if (!this.tioe.equals(that.tioe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(existsTable_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      existsTable_result typedOther = (existsTable_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetTioe()).compareTo(isSetTioe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tioe, typedOther.tioe);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case SUCCESS:
              if (field.type == TType.BOOL) {
                this.success = iprot.readBool();
                setSuccessIsSet(true);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case TIOE:
              if (field.type == TType.STRUCT) {
                this.tioe = new ThriftIOException();
                this.tioe.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetTioe()) {
        oprot.writeFieldBegin(TIOE_FIELD_DESC);
        this.tioe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("existsTable_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("tioe:");
      if (this.tioe == null) {
        sb.append("null");
      } else {
        sb.append(this.tioe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropTable_args implements TBase<dropTable_args._Fields>, java.io.Serializable, Cloneable, Comparable<dropTable_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropTable_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);

    public String tableName;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TABLE_NAME((short)1, "tableName");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(dropTable_args.class, metaDataMap);
    }

    public dropTable_args() {
    }

    public dropTable_args(
      String tableName)
    {
      this();
      this.tableName = tableName;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropTable_args(dropTable_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
    }

    public dropTable_args deepCopy() {
      return new dropTable_args(this);
    }

    @Deprecated
    public dropTable_args clone() {
      return new dropTable_args(this);
    }

    public String getTableName() {
      return this.tableName;
    }

    public dropTable_args setTableName(String tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropTable_args)
        return this.equals((dropTable_args)that);
      return false;
    }

    public boolean equals(dropTable_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(dropTable_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      dropTable_args typedOther = (dropTable_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tableName, typedOther.tableName);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TABLE_NAME:
              if (field.type == TType.STRING) {
                this.tableName = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.tableName);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("dropTable_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dropTable_result implements TBase<dropTable_result._Fields>, java.io.Serializable, Cloneable, Comparable<dropTable_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dropTable_result");

    private static final TField TIOE_FIELD_DESC = new TField("tioe", TType.STRUCT, (short)1);

    public ThriftIOException tioe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TIOE((short)1, "tioe");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TIOE, new FieldMetaData("tioe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(dropTable_result.class, metaDataMap);
    }

    public dropTable_result() {
    }

    public dropTable_result(
      ThriftIOException tioe)
    {
      this();
      this.tioe = tioe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dropTable_result(dropTable_result other) {
      if (other.isSetTioe()) {
        this.tioe = new ThriftIOException(other.tioe);
      }
    }

    public dropTable_result deepCopy() {
      return new dropTable_result(this);
    }

    @Deprecated
    public dropTable_result clone() {
      return new dropTable_result(this);
    }

    public ThriftIOException getTioe() {
      return this.tioe;
    }

    public dropTable_result setTioe(ThriftIOException tioe) {
      this.tioe = tioe;
      return this;
    }

    public void unsetTioe() {
      this.tioe = null;
    }

    /** Returns true if field tioe is set (has been asigned a value) and false otherwise */
    public boolean isSetTioe() {
      return this.tioe != null;
    }

    public void setTioeIsSet(boolean value) {
      if (!value) {
        this.tioe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TIOE:
        if (value == null) {
          unsetTioe();
        } else {
          setTioe((ThriftIOException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TIOE:
        return getTioe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TIOE:
        return isSetTioe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dropTable_result)
        return this.equals((dropTable_result)that);
      return false;
    }

    public boolean equals(dropTable_result that) {
      if (that == null)
        return false;

      boolean this_present_tioe = true && this.isSetTioe();
      boolean that_present_tioe = true && that.isSetTioe();
      if (this_present_tioe || that_present_tioe) {
        if (!(this_present_tioe && that_present_tioe))
          return false;
        if (!this.tioe.equals(that.tioe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(dropTable_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      dropTable_result typedOther = (dropTable_result)other;

      lastComparison = Boolean.valueOf(isSetTioe()).compareTo(isSetTioe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tioe, typedOther.tioe);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TIOE:
              if (field.type == TType.STRUCT) {
                this.tioe = new ThriftIOException();
                this.tioe.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetTioe()) {
        oprot.writeFieldBegin(TIOE_FIELD_DESC);
        this.tioe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("dropTable_result(");
      boolean first = true;

      sb.append("tioe:");
      if (this.tioe == null) {
        sb.append("null");
      } else {
        sb.append(this.tioe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class truncateTable_args implements TBase<truncateTable_args._Fields>, java.io.Serializable, Cloneable, Comparable<truncateTable_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("truncateTable_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField CLEAR_PARTITION_INFO_FIELD_DESC = new TField("clearPartitionInfo", TType.BOOL, (short)2);

    public String tableName;
    public boolean clearPartitionInfo;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TABLE_NAME((short)1, "tableName"),
      CLEAR_PARTITION_INFO((short)2, "clearPartitionInfo");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __CLEARPARTITIONINFO_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.CLEAR_PARTITION_INFO, new FieldMetaData("clearPartitionInfo", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(truncateTable_args.class, metaDataMap);
    }

    public truncateTable_args() {
    }

    public truncateTable_args(
      String tableName,
      boolean clearPartitionInfo)
    {
      this();
      this.tableName = tableName;
      this.clearPartitionInfo = clearPartitionInfo;
      setClearPartitionInfoIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public truncateTable_args(truncateTable_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      this.clearPartitionInfo = other.clearPartitionInfo;
    }

    public truncateTable_args deepCopy() {
      return new truncateTable_args(this);
    }

    @Deprecated
    public truncateTable_args clone() {
      return new truncateTable_args(this);
    }

    public String getTableName() {
      return this.tableName;
    }

    public truncateTable_args setTableName(String tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public boolean isClearPartitionInfo() {
      return this.clearPartitionInfo;
    }

    public truncateTable_args setClearPartitionInfo(boolean clearPartitionInfo) {
      this.clearPartitionInfo = clearPartitionInfo;
      setClearPartitionInfoIsSet(true);
      return this;
    }

    public void unsetClearPartitionInfo() {
      __isset_bit_vector.clear(__CLEARPARTITIONINFO_ISSET_ID);
    }

    /** Returns true if field clearPartitionInfo is set (has been asigned a value) and false otherwise */
    public boolean isSetClearPartitionInfo() {
      return __isset_bit_vector.get(__CLEARPARTITIONINFO_ISSET_ID);
    }

    public void setClearPartitionInfoIsSet(boolean value) {
      __isset_bit_vector.set(__CLEARPARTITIONINFO_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((String)value);
        }
        break;

      case CLEAR_PARTITION_INFO:
        if (value == null) {
          unsetClearPartitionInfo();
        } else {
          setClearPartitionInfo((Boolean)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case CLEAR_PARTITION_INFO:
        return new Boolean(isClearPartitionInfo());

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case CLEAR_PARTITION_INFO:
        return isSetClearPartitionInfo();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof truncateTable_args)
        return this.equals((truncateTable_args)that);
      return false;
    }

    public boolean equals(truncateTable_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_clearPartitionInfo = true;
      boolean that_present_clearPartitionInfo = true;
      if (this_present_clearPartitionInfo || that_present_clearPartitionInfo) {
        if (!(this_present_clearPartitionInfo && that_present_clearPartitionInfo))
          return false;
        if (this.clearPartitionInfo != that.clearPartitionInfo)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(truncateTable_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      truncateTable_args typedOther = (truncateTable_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tableName, typedOther.tableName);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetClearPartitionInfo()).compareTo(isSetClearPartitionInfo());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(clearPartitionInfo, typedOther.clearPartitionInfo);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TABLE_NAME:
              if (field.type == TType.STRING) {
                this.tableName = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case CLEAR_PARTITION_INFO:
              if (field.type == TType.BOOL) {
                this.clearPartitionInfo = iprot.readBool();
                setClearPartitionInfoIsSet(true);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.tableName);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(CLEAR_PARTITION_INFO_FIELD_DESC);
      oprot.writeBool(this.clearPartitionInfo);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("truncateTable_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("clearPartitionInfo:");
      sb.append(this.clearPartitionInfo);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class truncateTable_result implements TBase<truncateTable_result._Fields>, java.io.Serializable, Cloneable, Comparable<truncateTable_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("truncateTable_result");

    private static final TField TIOE_FIELD_DESC = new TField("tioe", TType.STRUCT, (short)1);

    public ThriftIOException tioe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TIOE((short)1, "tioe");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TIOE, new FieldMetaData("tioe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(truncateTable_result.class, metaDataMap);
    }

    public truncateTable_result() {
    }

    public truncateTable_result(
      ThriftIOException tioe)
    {
      this();
      this.tioe = tioe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public truncateTable_result(truncateTable_result other) {
      if (other.isSetTioe()) {
        this.tioe = new ThriftIOException(other.tioe);
      }
    }

    public truncateTable_result deepCopy() {
      return new truncateTable_result(this);
    }

    @Deprecated
    public truncateTable_result clone() {
      return new truncateTable_result(this);
    }

    public ThriftIOException getTioe() {
      return this.tioe;
    }

    public truncateTable_result setTioe(ThriftIOException tioe) {
      this.tioe = tioe;
      return this;
    }

    public void unsetTioe() {
      this.tioe = null;
    }

    /** Returns true if field tioe is set (has been asigned a value) and false otherwise */
    public boolean isSetTioe() {
      return this.tioe != null;
    }

    public void setTioeIsSet(boolean value) {
      if (!value) {
        this.tioe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TIOE:
        if (value == null) {
          unsetTioe();
        } else {
          setTioe((ThriftIOException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TIOE:
        return getTioe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TIOE:
        return isSetTioe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof truncateTable_result)
        return this.equals((truncateTable_result)that);
      return false;
    }

    public boolean equals(truncateTable_result that) {
      if (that == null)
        return false;

      boolean this_present_tioe = true && this.isSetTioe();
      boolean that_present_tioe = true && that.isSetTioe();
      if (this_present_tioe || that_present_tioe) {
        if (!(this_present_tioe && that_present_tioe))
          return false;
        if (!this.tioe.equals(that.tioe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(truncateTable_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      truncateTable_result typedOther = (truncateTable_result)other;

      lastComparison = Boolean.valueOf(isSetTioe()).compareTo(isSetTioe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tioe, typedOther.tioe);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TIOE:
              if (field.type == TType.STRUCT) {
                this.tioe = new ThriftIOException();
                this.tioe.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetTioe()) {
        oprot.writeFieldBegin(TIOE_FIELD_DESC);
        this.tioe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("truncateTable_result(");
      boolean first = true;

      sb.append("tioe:");
      if (this.tioe == null) {
        sb.append("null");
      } else {
        sb.append(this.tioe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class truncateColumn_args implements TBase<truncateColumn_args._Fields>, java.io.Serializable, Cloneable, Comparable<truncateColumn_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("truncateColumn_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField COLUMN_NAME_FIELD_DESC = new TField("columnName", TType.STRING, (short)2);

    public String tableName;
    public String columnName;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TABLE_NAME((short)1, "tableName"),
      COLUMN_NAME((short)2, "columnName");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.COLUMN_NAME, new FieldMetaData("columnName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(truncateColumn_args.class, metaDataMap);
    }

    public truncateColumn_args() {
    }

    public truncateColumn_args(
      String tableName,
      String columnName)
    {
      this();
      this.tableName = tableName;
      this.columnName = columnName;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public truncateColumn_args(truncateColumn_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetColumnName()) {
        this.columnName = other.columnName;
      }
    }

    public truncateColumn_args deepCopy() {
      return new truncateColumn_args(this);
    }

    @Deprecated
    public truncateColumn_args clone() {
      return new truncateColumn_args(this);
    }

    public String getTableName() {
      return this.tableName;
    }

    public truncateColumn_args setTableName(String tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public String getColumnName() {
      return this.columnName;
    }

    public truncateColumn_args setColumnName(String columnName) {
      this.columnName = columnName;
      return this;
    }

    public void unsetColumnName() {
      this.columnName = null;
    }

    /** Returns true if field columnName is set (has been asigned a value) and false otherwise */
    public boolean isSetColumnName() {
      return this.columnName != null;
    }

    public void setColumnNameIsSet(boolean value) {
      if (!value) {
        this.columnName = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((String)value);
        }
        break;

      case COLUMN_NAME:
        if (value == null) {
          unsetColumnName();
        } else {
          setColumnName((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case COLUMN_NAME:
        return getColumnName();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case COLUMN_NAME:
        return isSetColumnName();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof truncateColumn_args)
        return this.equals((truncateColumn_args)that);
      return false;
    }

    public boolean equals(truncateColumn_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_columnName = true && this.isSetColumnName();
      boolean that_present_columnName = true && that.isSetColumnName();
      if (this_present_columnName || that_present_columnName) {
        if (!(this_present_columnName && that_present_columnName))
          return false;
        if (!this.columnName.equals(that.columnName))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(truncateColumn_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      truncateColumn_args typedOther = (truncateColumn_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tableName, typedOther.tableName);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetColumnName()).compareTo(isSetColumnName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(columnName, typedOther.columnName);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TABLE_NAME:
              if (field.type == TType.STRING) {
                this.tableName = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case COLUMN_NAME:
              if (field.type == TType.STRING) {
                this.columnName = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.columnName != null) {
        oprot.writeFieldBegin(COLUMN_NAME_FIELD_DESC);
        oprot.writeString(this.columnName);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("truncateColumn_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("columnName:");
      if (this.columnName == null) {
        sb.append("null");
      } else {
        sb.append(this.columnName);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class truncateColumn_result implements TBase<truncateColumn_result._Fields>, java.io.Serializable, Cloneable, Comparable<truncateColumn_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("truncateColumn_result");

    private static final TField TIOE_FIELD_DESC = new TField("tioe", TType.STRUCT, (short)1);

    public ThriftIOException tioe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TIOE((short)1, "tioe");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TIOE, new FieldMetaData("tioe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(truncateColumn_result.class, metaDataMap);
    }

    public truncateColumn_result() {
    }

    public truncateColumn_result(
      ThriftIOException tioe)
    {
      this();
      this.tioe = tioe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public truncateColumn_result(truncateColumn_result other) {
      if (other.isSetTioe()) {
        this.tioe = new ThriftIOException(other.tioe);
      }
    }

    public truncateColumn_result deepCopy() {
      return new truncateColumn_result(this);
    }

    @Deprecated
    public truncateColumn_result clone() {
      return new truncateColumn_result(this);
    }

    public ThriftIOException getTioe() {
      return this.tioe;
    }

    public truncateColumn_result setTioe(ThriftIOException tioe) {
      this.tioe = tioe;
      return this;
    }

    public void unsetTioe() {
      this.tioe = null;
    }

    /** Returns true if field tioe is set (has been asigned a value) and false otherwise */
    public boolean isSetTioe() {
      return this.tioe != null;
    }

    public void setTioeIsSet(boolean value) {
      if (!value) {
        this.tioe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TIOE:
        if (value == null) {
          unsetTioe();
        } else {
          setTioe((ThriftIOException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TIOE:
        return getTioe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TIOE:
        return isSetTioe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof truncateColumn_result)
        return this.equals((truncateColumn_result)that);
      return false;
    }

    public boolean equals(truncateColumn_result that) {
      if (that == null)
        return false;

      boolean this_present_tioe = true && this.isSetTioe();
      boolean that_present_tioe = true && that.isSetTioe();
      if (this_present_tioe || that_present_tioe) {
        if (!(this_present_tioe && that_present_tioe))
          return false;
        if (!this.tioe.equals(that.tioe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(truncateColumn_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      truncateColumn_result typedOther = (truncateColumn_result)other;

      lastComparison = Boolean.valueOf(isSetTioe()).compareTo(isSetTioe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tioe, typedOther.tioe);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TIOE:
              if (field.type == TType.STRUCT) {
                this.tioe = new ThriftIOException();
                this.tioe.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetTioe()) {
        oprot.writeFieldBegin(TIOE_FIELD_DESC);
        this.tioe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("truncateColumn_result(");
      boolean first = true;

      sb.append("tioe:");
      if (this.tioe == null) {
        sb.append("null");
      } else {
        sb.append(this.tioe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class descTable_args implements TBase<descTable_args._Fields>, java.io.Serializable, Cloneable, Comparable<descTable_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("descTable_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);

    public String tableName;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TABLE_NAME((short)1, "tableName");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(descTable_args.class, metaDataMap);
    }

    public descTable_args() {
    }

    public descTable_args(
      String tableName)
    {
      this();
      this.tableName = tableName;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public descTable_args(descTable_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
    }

    public descTable_args deepCopy() {
      return new descTable_args(this);
    }

    @Deprecated
    public descTable_args clone() {
      return new descTable_args(this);
    }

    public String getTableName() {
      return this.tableName;
    }

    public descTable_args setTableName(String tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof descTable_args)
        return this.equals((descTable_args)that);
      return false;
    }

    public boolean equals(descTable_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(descTable_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      descTable_args typedOther = (descTable_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tableName, typedOther.tableName);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TABLE_NAME:
              if (field.type == TType.STRING) {
                this.tableName = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.tableName);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("descTable_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class descTable_result implements TBase<descTable_result._Fields>, java.io.Serializable, Cloneable, Comparable<descTable_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("descTable_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField TIOE_FIELD_DESC = new TField("tioe", TType.STRUCT, (short)1);

    public ThriftTableSchema success;
    public ThriftIOException tioe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      TIOE((short)1, "tioe");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ThriftTableSchema.class)));
      put(_Fields.TIOE, new FieldMetaData("tioe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(descTable_result.class, metaDataMap);
    }

    public descTable_result() {
    }

    public descTable_result(
      ThriftTableSchema success,
      ThriftIOException tioe)
    {
      this();
      this.success = success;
      this.tioe = tioe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public descTable_result(descTable_result other) {
      if (other.isSetSuccess()) {
        this.success = new ThriftTableSchema(other.success);
      }
      if (other.isSetTioe()) {
        this.tioe = new ThriftIOException(other.tioe);
      }
    }

    public descTable_result deepCopy() {
      return new descTable_result(this);
    }

    @Deprecated
    public descTable_result clone() {
      return new descTable_result(this);
    }

    public ThriftTableSchema getSuccess() {
      return this.success;
    }

    public descTable_result setSuccess(ThriftTableSchema success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThriftIOException getTioe() {
      return this.tioe;
    }

    public descTable_result setTioe(ThriftIOException tioe) {
      this.tioe = tioe;
      return this;
    }

    public void unsetTioe() {
      this.tioe = null;
    }

    /** Returns true if field tioe is set (has been asigned a value) and false otherwise */
    public boolean isSetTioe() {
      return this.tioe != null;
    }

    public void setTioeIsSet(boolean value) {
      if (!value) {
        this.tioe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ThriftTableSchema)value);
        }
        break;

      case TIOE:
        if (value == null) {
          unsetTioe();
        } else {
          setTioe((ThriftIOException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case TIOE:
        return getTioe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case TIOE:
        return isSetTioe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof descTable_result)
        return this.equals((descTable_result)that);
      return false;
    }

    public boolean equals(descTable_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_tioe = true && this.isSetTioe();
      boolean that_present_tioe = true && that.isSetTioe();
      if (this_present_tioe || that_present_tioe) {
        if (!(this_present_tioe && that_present_tioe))
          return false;
        if (!this.tioe.equals(that.tioe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(descTable_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      descTable_result typedOther = (descTable_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetTioe()).compareTo(isSetTioe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tioe, typedOther.tioe);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case SUCCESS:
              if (field.type == TType.STRUCT) {
                this.success = new ThriftTableSchema();
                this.success.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case TIOE:
              if (field.type == TType.STRUCT) {
                this.tioe = new ThriftIOException();
                this.tioe.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetTioe()) {
        oprot.writeFieldBegin(TIOE_FIELD_DESC);
        this.tioe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("descTable_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("tioe:");
      if (this.tioe == null) {
        sb.append("null");
      } else {
        sb.append(this.tioe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class addColumn_args implements TBase<addColumn_args._Fields>, java.io.Serializable, Cloneable, Comparable<addColumn_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("addColumn_args");

    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)1);
    private static final TField ADDED_COLUMN_NAME_FIELD_DESC = new TField("addedColumnName", TType.STRING, (short)2);

    public String tableName;
    public String addedColumnName;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TABLE_NAME((short)1, "tableName"),
      ADDED_COLUMN_NAME((short)2, "addedColumnName");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TABLE_NAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(_Fields.ADDED_COLUMN_NAME, new FieldMetaData("addedColumnName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(addColumn_args.class, metaDataMap);
    }

    public addColumn_args() {
    }

    public addColumn_args(
      String tableName,
      String addedColumnName)
    {
      this();
      this.tableName = tableName;
      this.addedColumnName = addedColumnName;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addColumn_args(addColumn_args other) {
      if (other.isSetTableName()) {
        this.tableName = other.tableName;
      }
      if (other.isSetAddedColumnName()) {
        this.addedColumnName = other.addedColumnName;
      }
    }

    public addColumn_args deepCopy() {
      return new addColumn_args(this);
    }

    @Deprecated
    public addColumn_args clone() {
      return new addColumn_args(this);
    }

    public String getTableName() {
      return this.tableName;
    }

    public addColumn_args setTableName(String tableName) {
      this.tableName = tableName;
      return this;
    }

    public void unsetTableName() {
      this.tableName = null;
    }

    /** Returns true if field tableName is set (has been asigned a value) and false otherwise */
    public boolean isSetTableName() {
      return this.tableName != null;
    }

    public void setTableNameIsSet(boolean value) {
      if (!value) {
        this.tableName = null;
      }
    }

    public String getAddedColumnName() {
      return this.addedColumnName;
    }

    public addColumn_args setAddedColumnName(String addedColumnName) {
      this.addedColumnName = addedColumnName;
      return this;
    }

    public void unsetAddedColumnName() {
      this.addedColumnName = null;
    }

    /** Returns true if field addedColumnName is set (has been asigned a value) and false otherwise */
    public boolean isSetAddedColumnName() {
      return this.addedColumnName != null;
    }

    public void setAddedColumnNameIsSet(boolean value) {
      if (!value) {
        this.addedColumnName = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TABLE_NAME:
        if (value == null) {
          unsetTableName();
        } else {
          setTableName((String)value);
        }
        break;

      case ADDED_COLUMN_NAME:
        if (value == null) {
          unsetAddedColumnName();
        } else {
          setAddedColumnName((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return getTableName();

      case ADDED_COLUMN_NAME:
        return getAddedColumnName();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TABLE_NAME:
        return isSetTableName();
      case ADDED_COLUMN_NAME:
        return isSetAddedColumnName();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof addColumn_args)
        return this.equals((addColumn_args)that);
      return false;
    }

    public boolean equals(addColumn_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && this.isSetTableName();
      boolean that_present_tableName = true && that.isSetTableName();
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      boolean this_present_addedColumnName = true && this.isSetAddedColumnName();
      boolean that_present_addedColumnName = true && that.isSetAddedColumnName();
      if (this_present_addedColumnName || that_present_addedColumnName) {
        if (!(this_present_addedColumnName && that_present_addedColumnName))
          return false;
        if (!this.addedColumnName.equals(that.addedColumnName))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(addColumn_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      addColumn_args typedOther = (addColumn_args)other;

      lastComparison = Boolean.valueOf(isSetTableName()).compareTo(isSetTableName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tableName, typedOther.tableName);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetAddedColumnName()).compareTo(isSetAddedColumnName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(addedColumnName, typedOther.addedColumnName);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TABLE_NAME:
              if (field.type == TType.STRING) {
                this.tableName = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case ADDED_COLUMN_NAME:
              if (field.type == TType.STRING) {
                this.addedColumnName = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.tableName);
        oprot.writeFieldEnd();
      }
      if (this.addedColumnName != null) {
        oprot.writeFieldBegin(ADDED_COLUMN_NAME_FIELD_DESC);
        oprot.writeString(this.addedColumnName);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("addColumn_args(");
      boolean first = true;

      sb.append("tableName:");
      if (this.tableName == null) {
        sb.append("null");
      } else {
        sb.append(this.tableName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("addedColumnName:");
      if (this.addedColumnName == null) {
        sb.append("null");
      } else {
        sb.append(this.addedColumnName);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class addColumn_result implements TBase<addColumn_result._Fields>, java.io.Serializable, Cloneable, Comparable<addColumn_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("addColumn_result");

    private static final TField TIOE_FIELD_DESC = new TField("tioe", TType.STRUCT, (short)1);

    public ThriftIOException tioe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TIOE((short)1, "tioe");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TIOE, new FieldMetaData("tioe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(addColumn_result.class, metaDataMap);
    }

    public addColumn_result() {
    }

    public addColumn_result(
      ThriftIOException tioe)
    {
      this();
      this.tioe = tioe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addColumn_result(addColumn_result other) {
      if (other.isSetTioe()) {
        this.tioe = new ThriftIOException(other.tioe);
      }
    }

    public addColumn_result deepCopy() {
      return new addColumn_result(this);
    }

    @Deprecated
    public addColumn_result clone() {
      return new addColumn_result(this);
    }

    public ThriftIOException getTioe() {
      return this.tioe;
    }

    public addColumn_result setTioe(ThriftIOException tioe) {
      this.tioe = tioe;
      return this;
    }

    public void unsetTioe() {
      this.tioe = null;
    }

    /** Returns true if field tioe is set (has been asigned a value) and false otherwise */
    public boolean isSetTioe() {
      return this.tioe != null;
    }

    public void setTioeIsSet(boolean value) {
      if (!value) {
        this.tioe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TIOE:
        if (value == null) {
          unsetTioe();
        } else {
          setTioe((ThriftIOException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TIOE:
        return getTioe();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TIOE:
        return isSetTioe();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof addColumn_result)
        return this.equals((addColumn_result)that);
      return false;
    }

    public boolean equals(addColumn_result that) {
      if (that == null)
        return false;

      boolean this_present_tioe = true && this.isSetTioe();
      boolean that_present_tioe = true && that.isSetTioe();
      if (this_present_tioe || that_present_tioe) {
        if (!(this_present_tioe && that_present_tioe))
          return false;
        if (!this.tioe.equals(that.tioe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(addColumn_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      addColumn_result typedOther = (addColumn_result)other;

      lastComparison = Boolean.valueOf(isSetTioe()).compareTo(isSetTioe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(tioe, typedOther.tioe);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TIOE:
              if (field.type == TType.STRUCT) {
                this.tioe = new ThriftIOException();
                this.tioe.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetTioe()) {
        oprot.writeFieldBegin(TIOE_FIELD_DESC);
        this.tioe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("addColumn_result(");
      boolean first = true;

      sb.append("tioe:");
      if (this.tioe == null) {
        sb.append("null");
      } else {
        sb.append(this.tioe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

}
